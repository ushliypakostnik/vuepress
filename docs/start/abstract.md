# Абстракция

Маниакально абстрагируйте все что только можно. Все что должно и может быть переиспользовано и любые конкретные значения, те, которые, когда-нибудь, но, в принципе, могут измениться. К примеру, на Stylus:

```stylus
// В @/stylus/utils/variables.styl:

$colors = {
  mint: #44c6a8,
  // ... другие конкретные значения цветов
}

// Создаем "основной цвет", абстрагируясь от конкретного цвета
$colors['primary'] = $colors.mint
// ... другие функциональные цвета
```

И теперь в любом месте где потребуется предоставить основной «брендовый» цвет:

```stylus
.selector
  color $colors.primary
```

Очевидно, что если весь остальной код будет аккуратно использовать правильную переменную - просто «по шелчку пальцев» возможно изменить этот основной цвет по всему интерфейсу!

Тоже самое касается любых качеств гайдлайна и дизайна, прежде всего, такой важной его составляющей как типографика. Или, например - медиа-запросы для адаптивности в большинстве случаев используют одни и теже значения - «брейкпоинты» - точки перехода, значения ширины окна браузера, в которых один «типоразмер» дизайна перестраивается в другой. **Основным признаком адаптивного дизайна как раз и является наличие таких типоразмеров - диапазонов ширины экрана для которых не меняется пространственная раскладка, сетки и типографика на всем протяжении.** Что, по сути, и позволяет дизайнерам покрыть «все случаи» с помощью нескольких макетов - по одному на каждый типоразмер.

Нужно помнить что плейсхолдеры не могут быть включены в медиа-запросы, но сами, при этом, могут их использовать. Вот простейший обычный очень реалистичный кейс - создадим стили препроцессора для "резинового контейнера для контента с отступами по краям вдвое меньшими на мобильных чем на остальных экранах" - очень распространенной обертки которая переиспользуется по всему интерфейсу. Объявляем переменные брекпоинтов, делаем на них удобную примесь принимающую контент в медиа-запросе, используем эту адаптивную примесь в плейсхолдере, и в конце-концов - растворяем этот кусок в конкретной утилите-классе - который единственный и скомпилируется:   

```stylus
// В @/stylus/utils/variables.styl:
// Project variables
//////////////////////////////////////////////////////
//////////////////////////////////////////////////////

// Sizes and layouts
//////////////////////////////////////////////////////

$gutter = 20px


// Breackpoints
//////////////////////////////////////////////////////

$breackpoints = {
  min: 320px,
  xs: 359px,
  sm: 768px,
  md: 1025px,
  lg: 1240px,
}

$breackpoints['xs-max'] = $breackpoints.sm - 1
$breackpoints['sm-max'] = $breackpoints.md - 1
$breackpoints['md-max'] = $breackpoints.lg - 1


// В @/stylus/utils/mixins.styl:
// Project mixins
//////////////////////////////////////////////////////
//////////////////////////////////////////////////////

// Media
//////////////////////////////////////////////////////
// Breackpoins in stylus/utils/variables.styl

$xs()
  @media only screen and (max-width $breackpoints.xs-max)
    {block}


// В @/stylus/utils/placeholders.styl:
// Project placeholders
//////////////////////////////////////////////////////
//////////////////////////////////////////////////////

// Rubber Container
$container
  width 100%
  padding-left $gutter
  padding-right $gutter

  +$xs()
    padding-left $gutter / 2
    padding-right $gutter / 2


// В @/stylus/core/utilities.styl:
// Project utilities
//////////////////////////////////////////////////////
//////////////////////////////////////////////////////

// Elements
//////////////////////////////////////////////////////

// Rubber Container
.container-fluid
  @extends $container
```

Код опять как будто выглядит громозким, «не проще ли было просто написать все с медиа-запросом в классе» и все. Но это обманчиво. Я просто демонстрирую правильный ход мыслей и действий.  **В маштабе большого проекта неукоснительное следования правильным принципам становиться категорически важным**. 