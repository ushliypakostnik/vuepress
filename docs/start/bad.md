# Препроцессор

## Простейший пример плохого кода
Безобразного кода с каждым днем становится все больше, несмотря на то, что больнее и эпичнее всего страдают от этого сами авторы, горе-разработчики. И если определенную функциональность или рендер можно покрыть тестами, то ошибки оформления выявляются только «ручками».

Также, просто парадоксально, что все программисты слышали о простых основополагающих принципах качественного программирования [KISS](https://ru.wikipedia.org/wiki/KISS_(%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF)) и [SOLID](https://ru.wikipedia.org/wiki/SOLID_(%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)), но подавляющее большинство напрочь забывает о них, когда речь заходит об организации оформления, представления веб-интерфейса.

В реальной ситуации - заказчик, покупатель вашего кода в любой момент может захотеть внести любые правки, и вы должны быть максимально к этому готовы.

Давайте посмотрим на самый простейший пример плохого кода на CSS:

```css
/* Примитивнейший пример обычного плохого кода на CSS */

/* Где-нибудь в файлах стилей: */

.selector--1 {
  width: 200px;
  height: 200px;
  border: 1px solid #ADADAD;
  border-radius: 3px;
  /* ... и дальше еще огромное количество самых разных правил */
}

.selector--2 {
  width: 200px;
  height: 400px;
  border: 1px solid #ADADAD;
  border-radius: 3px;
  /* ... и дальше еще огромное количество самых разных правил */
}
```

Не делайте так больше почти никогда! ))) Почему? Код валидный, «в браузере все по макету», да и все именно так обычно и пишут. Но все и не «верстают как бог», правильно? В контексте любого проекта чуть большего чем совсем крохотный, подобный код «плохой и чреват проблемами в будущем». Он **конкретен и невыразителен, излишен, его сложно модифицировать и переиспользовать**.

## А как надо?

На сегодняшний день стандартной практикой для разработки CSS-кода является использование [Препроцессора](https://developer.mozilla.org/ru/docs/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C/CSS_preprocessor), который отнюдь не превращает формальную спецификацию CSS в язык программирования, но дает синтаксису необходимую силу и мощь, актуальные возможности и эффективность. Если говорить совсем просто, то без него, **очень многие требования современного веб-дизайна иначе было бы крайне затруднительно реализовать, особенно в масштабе крупных проектов**.  

Справедливости ради, нужно упомянуть, что последние годы, в связи с стремительным ростом популярности компонентных js-фреймворков и их подходов, все больше сторонников набирают также различные «CSS-in-JS»-реализации (например: [Styled Components](https://styled-components.com/)). Скоро, вероятно, можно будет спокойно использовать переменные в самом CSS ([CSS Custom Properties](https://developer.mozilla.org/ru/docs/Web/CSS/Using_CSS_custom_properties)). Тема холиварная, существуют контексты и ситуации когда подобный CSS-in-JS подход может оказаться более оправданным и изящным, без сомнения. И даже существует масса реалистичных кейсов когда проще всего будет действительно обойтись несколькими наборами правил на CSS, а любое его расширение будет излишним. Но в общем случае, в реальной коммерческой практике, имхо, для верстки сложных дизайнов и интерфейсов удобнее и эффективнее всего сейчас использовать любой препроцессор, **и, шок - даже с компонентным фреймворком**, дальше я планирую показать «как именно это лучше всего делать». Препроцессоры дают максимум возможностей и позволяют стремиться к максимальной выразительности и переиспользуемости. Вот во что превратился бы «плохой код» выше в SCSS-синтаксисе, наверное - самого популярного на сегодняшний день препроцессора - [Sass](https://sass-scss.ru/):
```scss
// В @/scss/utils/_variables.scss:

$selector__size: 200px;

$colors__border: #adadad;

$border-radius: 3px;


// В @/scss/utils/_placeholders.scss:
%border-block {
  border: 1px solid $colors__border;
  border-radius: $border-radius;
}


// В @/scss/utils/_mixins.scss:
@mixin size($width, $height) {
  width: $width;
  height: $height;
}


// В любом месте проекта:
.selector {
  &--1,
  &--2 {
    @extend %border-block;
    /* ... включение других сущностей препроцессора
      и специфическиих правил общих для селекторов */
  }

  &--1 {
    @include size($selector__size, $selector__size);
    /* ... включение других сущностей препроцессора
      и специфических правил уникальных для селектора */
  }

  &--2 {
    @include size($selector__size, ($selector__size * 2));
    /* ... включение других сущностей препроцессора
      и специфических правил уникальных для селектора */
  }
}
```

Точно тоже самое легко сделать и на, кажется, недооцененном, но очень удачном [Stylus](https://stylus-lang.com/) - совершенно не важно какой именно расширенный синтаксис вы используете, главное как и зачем. Очень много раз мне приходилось видеть плохой чужой код написанный якобы для препроцессора, видимо, «потому что так сейчас модно», но, на самом деле, практически ничем не отличающийся от кода CSS. Не делайте так! Препроцессор дает нам крайне ценную возможность абстрагировать общие качества гайдлайна, стиль и основанные на нем частные стили, организовать их намного более выразительно и лаконично, легко модифицировать и переиспользовать при необходимости.

В данном, вырванном из контекста, но, при этом, вполне жизненном примере, кажется, что кода препроцессора - сильно больше. Он еще и раскидан по нескольким разным файлам, что, как будто, еще все усложняет. Зачем так напрягаться, а? Прежде всего, привычка начинать писать разметку с переменных и обобщений - очевидно грамотная. Перестаньте плодить изолированные глухие кряки с магическими числами, начните применять абстракцию! Делайте хорошо сразу, потому что вы почти никогда и ничего не переделаете «потом», на самом деле. «Когда наш стартап наконец взлетит», и как раз во многом из-за такого отношения он может и не взлететь, в результате. Чем детализированнее и сложнее ваш интерфейс, его дизайн, тем больше строк и времени вы будете «экономить» просто оптимизируя общие наборы правил, переиспользуя стили. Кроме того, **поддерживать код и, тем более, вносить серьезные изменения будет на порядок проще**.

Первый пример демонстрирует что на начальных этапах развития проекта хорошо продуманного кода препроцессора может быть даже визуально несколько больше, чем неорганизаванного, внутренее плоского, скучного CSS. Но давайте разберем очень часто встречающийся кейс, в котором мы очевидно сразу сильно экономим много трафика и явно оптимизируем возможную поддержку. Такое очень часто встречается: нам нужно создать большое количество, предположим - 20 штук - модификаторов одного селектора - квадратной иконки размеров в 100 пикселей - и поставить в них нужные картинки в бекграунд. В Sass мы можем написать цикл с [интерполяцией](https://sass-scss.ru/documentation/sassscript/interpolyatsiya/) для создания селектора модификатора и указания пути до ресурса. И хотя такая синтаксическая возможность не является чем-то идейно решающе важным - на практике она экономит кучу времени и повышает качество жизни на работе: 

```scss
// В @/scss/utils/_variables.scss:

// Paths
$images__path--root: "../assets/images/";

// Sizes 
$icons__size: 100px;

// Views
$icons: 20;

// В любом месте проекта:
.icon {
  $image-path: "../../../" + $image_path--root + "icons/";

  @include size($icons__size, $icons__size); // эта примесь уже создана выше

  @for $i from 1 through $icons {
    &.icon--#{$i} {
      background: url("#{$image-path}icon--#{$i}.svg") center center no-repeat;
    }
  }
}
```
Пример предполагает что в вашем проекте следующая структура:

```
.
├─ assets
│  └─ images
│     ├─ icon--1.svg
│     ├─ icon--2.svg
│     └─ ...
└─ sscs
   └─ utils
      ├─ _mixins.scss
      └─ _variables.scss
```

Теперь в шаблонах мы можем использовать:

```html
<div class="icon icon--1"></div>
```

Если вы желаете чтобы картинки были с осмысленными именами - можете перебирать список:

```scss

.icon {
  $image-path: "../../../" + $image_path--root + "icons/";
  $images: "name1", "name2", "name3"; // Список имен

  @include size($icons__size, $icons__size);

  @each $image in $images {
    &.icon--#{$image} {
      background: url("#{$image-path}#{$image}.svg") center center no-repeat;
    }
  }
}
```

Ну и раз уж мы упомянули интерполяцию, необходимо вспомнить еще один простой кейс, который сейчас часто нужен и в котором вам она точно пригодится - «посчитать с переменной»:

```scss
.selector {
  $width: 100px;

  width: calc(100vw - #{$width});
}
```

Используйте на полную мощность и изучайте подробно свои ключевые инструменты. Используйте свой интеллект и фантазию. В хорошем коде препроцессора наборы правил не повторяются и какдый селектор содержит только небольшое количество объявлений. **Повторяющиеся и похожие наборы, большое количество самых разных объявлений в селекторах - признак плохо организованного кода**. Пока бесконечный поиск и замена остаются вашим главным и единственным инструментом рефакторинга кода разметки - вы живете в камменном веке веб-технологий и еще даже не начинали верстать!) 

## Абстрагируй все!

Что такое дизайн, если совсем кратко? **Дизайн - это «гайдлайн» - строгая система, набор стилевых правил и ограничений, перечень констант, аксиом и отношений в разметке и оформлении интерфейса, которым он неукоснительно должен соответсвовать.** Задача верстальщика в том чтобы правильно воспринять эту систему и максимально эфективно перевести ее с языка графических прототипов в работающий по заявленным требованиям код.

Поэтому маниакально абстрагируй все что только можно. Все что должно и может быть переиспользовано и любые конкретные значения, те, которые, когда-нибудь, но, в принципе, могут измениться. К примеру, на Stylus:

```stylus
// В @/stylus/utils/variables.styl:

$colors = {
  mint: #44c6a8,
  // ... другие конкретные значения цветов
}

// Создаем "основной цвет", абстрагируясь от конкретного цвета
$colors['primary'] = $colors.mint
// ... другие "функциональные" цвета
```

И теперь в любом месте где потребуется предоставить основной «брендовый» цвет:

```stylus
.selector
  color $colors.primary
```

Очевидно, что если весь остальной код будет аккуратно использовать правильную переменную - просто «по шелчку пальцев» возможно изменить этот основной цвет по всему интерфейсу! Все это логично и закономерно приводить нас к **идее некой общей «стилевой базы» интерфейса, которую очевидно способен нам предоставить препроцессор, и которую было бы удобно и правильно использовать даже для оформления максимально изолированных компонентов**.


## Структура и стилевая база препроцессора

Дальше я покажу определенную логичную и простую структуру организации файлов препроцессора, которую использую на проектах сам. Но вы можете что-то делать совсем иначе и, в результате, придти к совсем другой, удобной именно для ваших методов работы системе. Важно не следовать каким-то зазубренным до автоматизма теориям и якобы «лучшим практикам», а гибко и к месту применять возможности, и даже, вероятно - все время немного экспериментировать, стараясь расти и меняться к лучшему. Категорически важно только то, что **ваши стили должны быть действительно всегда четко и понятно организованы**.

На практике во многих командах «вытесняют» и игнорируют выгоду от более продвинутых и аккуратных подходов к разметке. Ведь это требует опреденных затрат на коммуникацию. Например, очень часто файлы стилей даже на препроцессоре - тупо и незамысловато «складируются в кучу» и практически никак не связаны друг-с-другом. Признайтесь себе наконец честно: даже аккуратная подробная компонентность, хоть и позволяет решить проблему на самом примитивном физическом уровне, она вообще не рещает ее глобально, на уровне абстракций. Наоборот - **компонентность даже еще несколько затрудняет решение, так как строится именно на противоположных глобальности препроцессора, изолирующих подходах**. Ваша куча это попрежнему невыразительная невнятная неповоротливая куча, просто теперь она еще и разделена на множество подобных и глобально излишних куч, поменьше.

Но давайте уже организуем препроцессор, если с SCSS:

```
.
└─ sscs
   ├─ core // обшие и компилируемые сущности препроцессора
   │  ├─ _animations.scss // keyframes
   │  ├─ _base.scss // минимальная нормализация основных HTML-элементов
   │  ├─ _grid.scss // сетки
   │  ├─ _typography.scss // типографика
   │  └─ _utilities.scss // быстрые удобные классы-утилиты для включения прямо в разметку
   ├─ libraries // папка с файлами стилизаций сторонних модулей
   │  └─ _modal.scss - например какая-нибудь готовая модаль
   ├─ project // стили конкретного проекта
   │  ├─ _elements.scss // отдельные простые элементы-компоненты
   │  ├─ _fixes.scss // этот файл всегда должен быть практически пустой, исключая общеизвестные "проблемы браузеров"
   │  ├─ _layout.scss - стили общей для всех страниц GUI-обертки над контентом интерфейса
   │  └─ _widgets.scss - сложные составные комбинации простых элементов-компонентов
   ├─ utils // обшие и некомпилируемые основные сущности препроцессора
   │  ├─ _functions.scss // на практике нужны крайне редко
   │  ├─ _mixins.scss // параметризируемые и способные принимать контент примеси-микстуры
   │  ├─ _placeholders.scss // повторяющиеся наборы правил - растворы
   │  └─ _variables.scss // самый важный файл с переменными )
   ├─ _main.scss // точка сборки всех стилей препроцессора
   └─ _stylebase.scss // стилевая база
```

Тоесть, на самом деле - **порядок сборки всей кухни имеет значение**, конечно же:

```scss
// В @/scss/_stylebase.scss:
// Stylebase
//////////////////////////////////////////////////////
//////////////////////////////////////////////////////

// Uncompiled kitchen
@import "./utils/_functions";
@import "./utils/_variables";
@import "./utils/_mixins";
@import "./utils/_placeholders";

// Core base normal style and common utils
@import "./core/_animations";
@import "./core/_typography";
@import "./core/_grid";
@import "./core/_base";
@import "./core/_utilities";


// В @/scss/_main.scss:
// Project styles
//////////////////////////////////////////////////////
//////////////////////////////////////////////////////

// Stylebase for components
@import "_stylebase";

// App styles
@import "./project/_fixes";
@import "./project/_elements";
@import "./project/_widgets";
@import "./project/_layout";

/* External libraries customization */
@import "./libraries/_modal";
```

Итак, **«стилевой базой» мы будем называть некое основное ядро стилей, доступный всем остальным компонентам системы общий код препроцессора**. Более детально, он состоит из условно двух разных видов файлов:

1. Растворяемые при компиляции инструменты-помощники, сущности позволяющие генерировать лаконичный, оптимальный, связный код:
    1. **функции**
    2. **переменные**
    3. **параметризируемые примеси**
    4. **включения-плейсхолдеры**

2. Компилируемые глобальные стили:
    1. **анимации keyframes**
    2. **типографика**
    3. **сетки**
    4. **базовая нормализация основных HTML-элементов**
    5. **утилитарные классы-помощники для разметки**

Удобно держать подобную минимальную «кухню» наготове в ваших стартовых проектах, чтобы с самого начала работы быстро настраивать стилизацию под конкретные требования и гайдлайн.

У меня вот, например, можно посмотреть - есть различные такие заготовки-«болванки» для быстрого старта на разных комбинациях актуальных технологий:
* [React c TypeScript и Stylus](https://github.com/ushliypakostnik/ts-react-stylus-i18next/tree/master/src/stylus)
* [Vue c SCSS](https://github.com/ushliypakostnik/vue-scss-i18next/tree/master/src/styles)
* [Webpack c SCSS и Nunjucks](https://github.com/ushliypakostnik/webpack-start/tree/master/src/scss)

## Адаптивная кухня

Стилевая база препроцессора призвана предоставлять все основные качества, константы гайдлайна и дизайна, например, такую важную его общую составляющую как типографика. Или, например - медиа-запросы для адаптивности в большинстве случаев используют одни и теже значения - **брекпоинты** - точки перехода, значения ширины окна браузера, при которых один статичный **типоразмер** дизайна перестраивается в другой. **Признаком адаптивного дизайна как раз и является наличие нескольких таких статичных типоразмеров - диапазонов ширины экрана для которых не меняется пространственная раскладка, сетки и типографика на всем протяжении.** Что, по сути, и позволяет дизайнерам ловко покрыть «все случаи» с помощью нескольких макетов - по одному на каждый типоразмер.

Нужно не забывать, что кроме ньюансов при комплияции, **плейсхолдеры, в отличие от параметризированных миксинов, не могут быть включены в медиа-запросы, но сами, при этом, могут их использовать**. Давайте возьмем простейший обычный реалистичный кейс. Напишем стили препроцессора предоставляющие «резиновый контейнера для контента с отступами по краям вдвое меньшими на мобильных чем на остальных экранах». Обычно такой элемент не «обозначен явно», но на самом деле - подразумевается как обертка в любом адаптивном макете и часто переиспользуется по всему интерфейсу. Первым делом - объявляем переменную мобильного брекпоинта, создаем на ней удобную для использования стандартную примесь принимающую контент в медиа-запросе, используем эту адаптивную примесь в плейсхолдере для корректировки внутренних отступов, и в конце-концов - растворяем этот набор в конкретной утилите-классе. Только этот класс и будет скомпилирован в результате:

```stylus
// В @/stylus/utils/variables.styl:
// Project variables
//////////////////////////////////////////////////////
//////////////////////////////////////////////////////

// Sizes
//////////////////////////////////////////////////////

$gutter = 20px


// Breackpoints
//////////////////////////////////////////////////////

$breackpoints = {
  tablet: 768px,
}

$breackpoints['mobile--max'] = $breackpoints.tablet - 1


// В @/stylus/utils/mixins.styl:
// Project mixins
//////////////////////////////////////////////////////
//////////////////////////////////////////////////////

// Media
//////////////////////////////////////////////////////
// Breakpoints in @/stylus/utils/variables.styl

$mobile()
  @media only screen and (max-width $breackpoints.mobile--max)
    {block}


// В @/stylus/utils/placeholders.styl:
// Project placeholders
//////////////////////////////////////////////////////
//////////////////////////////////////////////////////

// Rubber Container
$container
  width 100%
  padding-left $gutter
  padding-right $gutter

  +$mobile()
    padding-left $gutter / 2
    padding-right $gutter / 2


// В @/stylus/core/utilities.styl:
// Project utilities
//////////////////////////////////////////////////////
//////////////////////////////////////////////////////

// Elements
//////////////////////////////////////////////////////

// Rubber Container
.container-fluid
  @extends $container
```

Теперь у этих элементов - будут одинаковые правильные адаптивные отступы по краям:

```html
<div id="element1">
  <div class="container-fluid"></div>
</div>

<div id="element2">
  <div class="container-fluid"></div>
</div>

<!-- Или можно даже так, но лучше, на самом деле, не надо: -->
<div id="element3" class="container-fluid"></div>
```

Код опять как будто выглядит излишне громозким, «не проще ли было просто написать все с медиа-запросом в классе и готово». Нет, это обманчиво, и если вы все еще мыслите так, то вам стоит либо совсем перестать читать, либо перечитать эту главу с самого начала. Я просто демонстрирую правильный ход мыслей и действий. Вы можете опираться на другие единицы измерения, написать все в каком-то немного другом синтаксисе, примеров в сети масса, но для быстрого и надежного адаптивного дизайна вам обязательно непреложно _нужно «что-то такое»_, нечто, предоставляющее возможность воздействовать на оформление через систему брекпоинтов и типоразмеров. Особенно полезно принять такое соглашение и стандартизацию при работе над проектом командой. **В масштабе большого проекта неукоснительное следование принципам и правилам становиться категорически важным**.

Справедливости ради, нужно упомянуть что Custom Properties «не умеют быть брекпоинтами», что, кажется, их нелепый минус, но современные спецификации пространственной раскладки [Grid](https://developer.mozilla.org/ru/docs/Web/CSS/CSS_Grid_Layout/Basic_Concepts_of_Grid_Layout) и [Flexbox](https://developer.mozilla.org/ru/docs/Learn/CSS/CSS_layout/Flexbox) умеют делать некоторые магические вещи с расладкой даже без медиа-запросов. В любом случае, использование современных нативных сеток в связке с описанным здесь адаптивным препроцессором и кажется самым эффективным подходом.

На самом деле, нам осталось совсем немного для того чтобы «все понять про адаптивный дизайн». Давайте сделаем не «резиновый» контейнер - тоесть тянущийся на всю доступную ширину, а с фиксированной для каждого типоразмера шириной. Пусть в нашем дизайне только три типоразмера: все лэптопы-ноуты, таблетки и мобилы. По сути это и будет самая простая основная «рамочная» конcтрукция любого «адаптивного» дизайна.

Очевидно, что ширина контейнера для контента для каждого типоразмера - несколько меньше чем его нижний брекпоинт. А на мобильных элемент «становится резиновым». Добавим к кухне:

```stylus
// В @/stylus/utils/variables.styl:
// Project variables
//////////////////////////////////////////////////////
//////////////////////////////////////////////////////

// Sizes
//////////////////////////////////////////////////////

$container__desktop = 1080px;
$container__tablet = 700px;


// Breackpoints
//////////////////////////////////////////////////////

$breackpoints = {
  tablet: 768px,
  desktop: 1240px,
}

$breackpoints['tablet--max'] = $breackpoints.desktop - 1


// В @/stylus/utils/mixins.styl:
// Project mixins
//////////////////////////////////////////////////////
//////////////////////////////////////////////////////

// Media
//////////////////////////////////////////////////////
// Breakpoints in @/stylus/utils/variables.styl

$desktop()
  @media only screen and (min-width $breackpoints.desktop)
    {block}

$gadgets()
  @media only screen and (max-width $breackpoints.tablet--max)
    {block}

$tablet()
  @media only screen and (min-width $breackpoints.tablet) and (max-width $breackpoints.tablet--max)
    {block}

$not-mobile()
  @media only screen and (min-width $breackpoints.tablet)
    {block}

$landscape()
  @media only screen and (orientation: landscape)
    {block}

$portrait()
  @media only screen and (orientation: portrait)
    {block}


// В @/stylus/core/utilities.styl:
// Project utilities
//////////////////////////////////////////////////////
//////////////////////////////////////////////////////

// Elements
//////////////////////////////////////////////////////

// Rubber Container
.container
  @extends $container // раствор создан выше
  margin 0 auto // по центру

  +lg()
    max-width $container__desktop

  +sm()
    max-width $container__tablet
```

Так предоставляется простая удобная адаптивность. Набор примесей принимающих контент в медиа-запросах - дает нам надежный стандартизированный доступ к специфической стилизации элементов и виджетов в необходимом диапазоне размеров экранов, в любом месте кода препроцессора.

Но, кроме этого, еще со времен когда я часто использовал Bootstrap 3, у меня остался формирующий удобные утилиты пассаж с обычно огульно осуждаемым, но на самом деле очень полезным в некоторых реальных ситуациях флагом **!important** [для простой быстрой стилизации сторонних модулей, которые выставлют стили инлайн через javascript, или тут, например - с ним надежнее]. Этот код предоставляет более «грубое и внешнее» решение - набор, созданных с помощью наших стандартных адаптивных примесей, утилитарных классов для принудительного включения прямо в разметку шаблонов:

```stylus
// В @/stylus/core/utilities.styl:
// Visibility utilities
//////////////////////////////////////////////////////

// stylelint-disable declaration-no-important
.visible--desktop,
.visible--gadgets,
.visible--tablet,
.visible--mobile,
.visible--desktop--inline-block,
.visible--gadgets--inline-block,
.visible--tablet-inline-block,
.visible--mobile--inline-block,
.visible--desktop--inline,
.visible--gadgets--inline,
.visible--tablet--inline,
.visible--mobile--inline
  display none !important

.visible--desktop
  +$not-gadgets()
    display block !important

.visible--gadgets
  +$gadgets()
    display block !important

.visible--tablet
  +$sm()
    display block !important

.visible--mobile
  +$xs()
    display block !important

.visible--desktop--inline-block
  +$not-gadgets()
    display inline-block !important

.visible--gadgets--inline-block
  +$gadgets()
    display inline-block !important

.visible--tablet--inline-block
  +$sm()
    display inline-block !important

.visible--mobile--inline-block
  +$xs()
    display inline-block !important

.visible--desktop--inline
  +$not-gadgets()
    display inline !important

.visible--gadgets--inline
  +$gadgets()
    display inline !important

.visible--tablet--inline
  +$sm()
    display inline !important

.visible--mobile--inline
  +$xs()
    display inline !important

.hidden--desktop
  +$not-gadgets()
    display none !important

.hidden--gadgets
  +$gadgets()
    display none !important

.hidden--tablet
  +$sm()
    display none !important

.hidden--mobile
  +$xs()
    display none !important
// stylelint-enable declaration-no-important
```
 
Дизайнеры склонны мыслить «статично», они обусловлены рамками размера макета и пропорции в которой рисуют. И поэтому, например, часто выставляют принудительные переносы в тексте, хотя лучше этого не делать, позоляя тексту переноситься «нативно», и ограничивая его только по максимальной ширине - **в реальности экраны очень разные**. Но если вам необходимо стравиться с таким поведением - не стоит игнорировать проблему с пробелом, особенно если заголовок отбит центрально, и очень удобно применить адаптивные классы прямо в HTML:
 
 ```html
<h2>Очень-очень длинный заголовок<br class="visible--mobile--inline" /><span class="hidden--mobile"> </span>с принидительным переносом на мобильных</h2>
``` 

В принципе, это все, что нужно знать у уметь для того чтобы начать делать хорошую адаптивную верстку.

## Типографика

Спросите любого нормального дизайнера: «Что в стиле и оформлении веб-интерфейса (тоесть в UI, а не в UI/UX) самое главное?». Думаю, многие ответят: «Типографика». Многим заказчикам и пользователям нравятся «рюшечки и котики», или, очень важно - **на самом деле ваша верстка должна быть уверено доступна с клавиатуры без мыши, или даже для слабовидящих людей**. Но все же, типографика и текстовый контент категорически важны, и должны быть с перманентно одинаковым оформлением и хорошо читаемы, по крайней мере.

Сейчас мы организовали препроцессор, его стилевую базу и добавили в нее стандартный инструментарий для адаптивности. Давайте сделаем типографику, такую чтобы можно было как в истории рассказаной во вступлении к этому пособию «вообще все контролировать». Тут я тоже обычно использую подход «как в Bootstrap 3» на базовом кегле в пикселях [потому что в макетах оно именно в пикселях], предположим что у нас есть всего три основных кегля и два начертания шрифта, пишем на SCSS:

```scss
// В @/src/scss/core/_typography.scss:
// Typographic variables
//////////////////////////////////////////////////////

// Good line-height and letter-spacing
$line-height_base: 1.428571429;
$normal-letter-spacing: normal;

// Guide

$font-size--base: 16px;
$font-size__coefficient--large: 2.5;
$font-size__coefficient--normal: 1.5;
$font-size__coefficient--small: 1;

$font-size--large: round($font-size--base * $font-size__coefficient--large); // 40px
$font-size--normal: round($font-size--base * $font-size__coefficient--normal); // 24px
$font-size--small: round($font-size--base * $font-size__coefficient--small); // 16px

$line-height--computed: round($font-size--base * $line-height--base);
$line-height--large: floor($line-height--computed * $font-size__coefficient--large); // 55px
$line-height--normal: floor($line-height--computed * $font-size__coefficient--normal); // 35px
$line-height--small: floor($line-height--computed * $font-size__coefficient--small); // 23px

$font-family__sans: Helvetica, Arial, sans-serif;
$font-weight__sans__regular: 400;
$font-weight__sans__bold: 700;
```

Я думаю, тут все просто и понятно - мы используем базовый кегль, коэфициенты для основных кеглей из гайда, и стандартный коэфициент для интерлиньяжа, «хорошей высоты строки». И вот тут - давайте сделаем стандартную примесь которую будем использовать повсеместно. Для отдачи типографики во все текстовые поля интерфейса:  

```scss
// Universal Typographic Mixin
//////////////////////////////////////////////////////

// We use one, only one, Karl, a universal mixin for all cases !!!!!!!!!!

@mixin text($font-family, $font-size, $font-weight) {
  font-family: $font-family;
  font-size: $font-size;
  font-weight: $font-weight;
  letter-spacing: $normal-letter-spacing;

  @if $font-size == $font-size--large {
    line-height: $line-height--large;
  } @else if $font-size == $font-size--normal {
    line-height: $line-height--normal;
  } @else if $font-size == $font-size--small {
    line-height: $line-height--small;
  } @else {
    line-height: floor($font-size * $line-height--base);
  }
}
```
Теперь, если вам нужно, например, изменить какой-то стандартный кегль для определенного типоразмера (так очень часто бывает), вы можете сделать это для всего интерфейса с помощью включения адаптивной примеси прямо в «единую примесь для типографики». Просто добавим переменную и условие в примесь:
 
```scss
$font-size__coefficient--large--mobile: 2;

@mixin text($font-family, $font-size, $font-weight) {
  @if $font-size == $font-size--large {
    @include xs {
      font-size: round($font-size--base * $font-size__coefficient--large--mobile); // 32px
      line-height: floor($line-height--computed * $font-size__coefficient--large--mobile);// 46px
    }
  }
}
```

В случаях когда необходимо передать специфическую высоту строки, такое правило передается после универсальной примеси:

```scss
// В любом месте проекта:
.selector {
  @include text($font-family_sans, $line-height_small, $font-weight_sans_bold);
  line-height: 17px;
}
```

Мы можем раздать стандартную типографику по заголовкам, в параграф, а также сделать утилиту для включения прямо в разметку:

```scss
// Base Typographic
//////////////////////////////////////////////////////

p {
  margin-bottom: $gutter / 2;
  @include text($font-family__sans, $font-size--small, $font-weight__sans__regular);

  // Можно применить адаптивную примесь чтобы изменить поведение более локально - только для этих элемента
  @include xs {
    @include text($font-family__sans, $font-size--small * 1.2, $font-weight__sans__regular;
  }
}

h1, h2 {
  @include text($font-family__sans, $font-size--large, $font-weight__sans__bold);
}

h3, h4 {
  @include text($font-family__sans, $font-size--normal, $font-weight__sans__bold);
}

h5, h6 {
  @include text($font-family__sans, $font-size--small, $font-weight__sans__bold);
}

strong {
  font-weight: $font-weight__sans__bold;
}

.text {
  &--large {
    @include text($font-family__sans, $font-size--large, $font-weight__sans__bold);
  }

  &--normal {
    @include text($font-family__sans, $font-size--small, $font-weight__sans__bold);
  }

  &--small {
    @include text($font-family_sans_ui, $font-size_small, $font-weight_sans-ui_regular);
  }

  &--center {
    text-align: center;
  }
}
```

Дальше уже опять начинается, с одной стороны, фантазия и творчество, а с другой, во многом - конкретные требования проекта, гайдлайна, макетов. Просто вы должны начать **неукоснительно использовать стандартизированные подходы и абстракции**. Во всем.

Здесь можно посмотреть как точно такая же управляемая минимальная типографическая кухня реализована [на Stylus](https://github.com/ushliypakostnik/ts-react-stylus-i18next/blob/master/src/stylus/core/typography.styl).

## Нормализация

В современных условиях верстая только для modern bro, вы можете не заморачиваться каким-то специальным сбросом-нормалайзом и использовать для этих целей специальный файл стилевой базы, например [на SCSS](https://github.com/ushliypakostnik/vue-scss-i18next/blob/master/src/styles/core/_base.scss) или [на Stylus](https://github.com/ushliypakostnik/ts-react-stylus-i18next/blob/master/src/stylus/core/base.styl).

Содержание этого файла должно быть крайне минималистиченым, очень аккуратным. Базовая нормализация основных HTML-элментов, стили для html и body, блоки. Нестандартное поведение. Какие-то специфические элементы, например - плейсхолдеры.

```scss
// No outline on focus controls!!!
button,
input,
textarea,
a {
  // stylelint-disable-next-line declaration-no-important
  outline: none !important;

  &:hover,
  &:active,
  &:focus {
    // stylelint-disable-next-line declaration-no-important
    outline: none !important;
  }
}
```

Стили здесь, это то что должно быть точно и вообще везде! Не наносите никакое оформление и кастомизацию с помощью этих правил (только на **\<body>** и **\<html>**)! Нормализуйте и готовьте! Пока лишним будет объяснять почему, но это особенно важно если вы собираетесь использовать описанные здесь подходы с компонентным фреймворком.
