# Препроцессор

## Простейший пример плохого кода
Безобразного кода с каждым днем становится все больше, несмотря на то, что больнее всего страдают от этого сами авторы, горе-разработчики. И если определенную функциональность или рендер можно покрыть тестами, то ошибки оформления выявляются только «ручками».

Также, просто парадоксально, что все программисты слышали о простых основополагающих принципах качественного программирования [KISS](https://ru.wikipedia.org/wiki/KISS_(%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF)) и [SOLID](https://ru.wikipedia.org/wiki/SOLID_(%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)), но подавляющее большинство напрочь забывает о них, когда речь заходит об организации оформления, представления веб-интерфейса.

В реальной ситуации - заказчик, покупатель вашего кода в любой момент может захотеть внести любые правки, и вы должны быть максимально к этому готовы.

Давайте посмотрим на самый простейший пример плохого кода на CSS:

```css
/* Примитивнейший пример обычного плохого кода на CSS */

/* Где-нибудь в файлах стилей: */

.selector--1 {
  width: 200px;
  height: 200px;
  border: 1px solid #ADADAD;
  border-radius: 3px;
  /* ... и дальше еще огромное количество самых разных правил */
}

.selector--2 {
  width: 200px;
  height: 400px;
  border: 1px solid #ADADAD;
  border-radius: 3px;
  /* ... и дальше еще огромное количество самых разных правил */
}
```

Не делайте так больше почти никогда! ))) Почему? Код валидный, «в браузере все по макету», да и все именно так обычно и пишут. Но все и не «верстают как бог», правильно? В большинстве случаев, а в любом проекте чуть большем чем совсем крохотный, подобный код «плохой и чреват проблемами в будущем» потому что он **конкретен и невыразителен, излишен, его сложно модифицировать и переиспользовать**.

## А как надо?

На сегодняшний день стандартной практикой для разработки CSS-кода является использование [Препроцессора](https://developer.mozilla.org/ru/docs/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C/CSS_preprocessor), который отнюдь не превращает формальную спецификацию CSS в язык программирования, но дает синтаксису необходимую силу и мощь, актуальные возможности и эффективность. Если говорить совсем просто, то без него, **очень многие требования современного веб-дизайна иначе было бы крайне затруднительно реализовать, особенно в маштабе крупных проектов**.  

Справедливости ради, нужно упомянуть, что последние годы, в связи с стремительным ростом популярности компонентных js-фреймворков и их подходов, все больше сторонников набирают также различные «CSS-in-JS»-реализации (например: [Styled Components](https://styled-components.com/)). Скоро, вероятно, можно будет спокойно использовать переменные в самом CSS ([CSS Custom Properties](https://developer.mozilla.org/ru/docs/Web/CSS/Using_CSS_custom_properties)). Тема холиварная, существуют контексты и ситуации когда подобный подход может оказаться более оправданным и изящным, без сомнения. Существует масса реалистичных кейсов когда проще всего будет действительно обойтись несколькими наборами правил на CSS, а любое его расширение будет излишним. Но в общем случае, в реальной коммерческой практике, имхо, для верстки сложных дизайнов и интерфейсов удобнее и эффективнее всего сейчас использовать любой препроцессор, **и, шок - даже с компонентным фреймворком**, дальше я планирую показать «как именно это лучше всего делать». Препроцессоры дают максимум возможностей и позволяют стремиться к максимальной выразительности и переиспользуемости. Вот во что превратился бы «плохой код» выше в SCSS-синтаксисе, наверное - самого популярного на сегодняшний день препроцессора - [Sass](https://sass-scss.ru/):
```scss
// В @/scss/utils/_variables.scss:

$selector__size: 200px;

$colors__border: #adadad;

$border-radius: 3px;


// В @/scss/utils/_placeholders.scss:
%border-block {
  border: 1px solid $colors__border;
  border-radius: $border-radius;
}


// В @/scss/utils/_mixins.scss:
@mixin size($width, $height) {
  width: $width;
  height: $height;
}


// В любом месте проекта:
.selector {
  &--1,
  &--2 {
    @extend %border-block;
    /* ... включение других сущностей препроцессора
      и специфическиих правил общих для селекторов */
  }

  &--1 {
    @include size($selector__size, $selector__size);
    /* ... включение других сущностей препроцессора
      и специфических правил уникальных для селектора */
  }

  &--2 {
    @include size($selector__size, ($selector__size * 2));
    /* ... включение других сущностей препроцессора
      и специфических правил уникальных для селектора */
  }

}
```

Точно тоже самое легко сделать и на, кажется, недооцененном, но очень удачном [Stylus](https://stylus-lang.com/) - совершенно не важно какой именно расширенный синтаксис вы используете, главное как и зачем. Очень много раз мне приходилось видеть плохой чужой код написанный якобы для препроцессора, видимо, «потому что так сейчас модно», но, на самом деле, практически ничем не отличающийся от кода CSS. Не делайте так! Препроцессор дает нам крайне ценную возможность абстрагировать общие качества гайдлайна, стиль и основанные на нем частные стили, организовать их намного более выразительно и лаконично, легко модифицировать и переиспользовать при необходимости.

В данном, вырванном из контекста, но, при этом, вполне жизненном примере, кажется, что кода препроцессора - сильно больше. В реальной ситуации на любом мало-мальски крупном проекте это очень быстро становится не так, и чем детализированнее и сложнее ваш интерфейс, его дизайн, тем больше строк и времени вы будете «экономить» просто оптимизируя общие наборы правил, переиспользуя стили. Кроме того, **поддерживать код и, тем более, вносить серьезные изменения будет на порядок проще**.

Первый пример демонстрирует что на начальных этапах развития проекта хорошо продуманного кода препроцессора может быть даже визуально несколько больше, чем неорганизаванного, внутренее плоского CSS. Но давайте разберем очень часто встречающийся кейс, в котором мы очевидно сразу сильно экономим много трафика и явно оптимизируем возможную поддержку. Такое очень часто встречается: нам нужно создать большое количество, предположим - 20 штук - модификаторов одного селектора - квадратной иконки размеров в 100 пикселей - и поставить в них нужные картинки в бекграунд. В Sass мы можем написать цикл с [интерполяцией](https://sass-scss.ru/documentation/sassscript/interpolyatsiya/) для создания селектора модификатора и указания пути до ресурса. И хотя такая синтаксическая возможность не является чем-то идейно решающе важным - на практике она экономит кучу времени и повышает качество жизни на работе: 

```scss
// В @/scss/utils/_variables.scss:

// Paths
$images__path--root: "../assets/images/";

// Sizes 
$icons__size: 100px;

// Views
$icons: 20;

// В любом месте проекта:
.icon {
  $image-path: "../../../" + $image_path--root + "icons/";

  @include size($icons__size, $icons__size); // эта примесь уже создана выше

  @for $i from 1 through $icons {
    &.icon--#{$i} {
      background: url("#{$image-path}icon--#{$i}.svg") center center no-repeat;
    }
  }
}
```
Пример предполагает что в вашем проекте следующая структура:

```
.
├─ assets
│  └─ images
│     ├─ icon--1.svg
│     ├─ icon--2.svg
│     └─ ...
└─ sscs
   └─ utils
      └─ _variables.scss
```

Теперь в шаблонах мы можем использовать:

```html
<div class="icon icon--1"></div>
```

Если вы желаете чтобы картинки были с осмысленными именами - можете перебирать список:

```scss

.icon {
  $image-path: "../../../" + $image_path--root + "icons/";
  $images: "name1", "name2", "name3"; // Список имен

  @include size($icons__size, $icons__size);

  @each $image in $images {
    &.icon--#{$image} {
      background: url("#{$image-path}#{$image}.svg") center center no-repeat;
    }
  }
}
```

Ну и раз уж мы упомянули интерполяцию, необходимо вспомнить еще один очень кейс, который сейчас часто встречается и в котором вам она точно пригодится - «посчитать с переменной»:

```scss
.selector {
  $width: 100px;

  width: calc(100vw - #{$width});
}
```

Используйте на полную мощность и изучайте подробно свои ключевые инструменты. Используйте свой интеллект и фантазию. В хорошем коде препроцессора наборы правил не повторяются и какдый селектор содержит только небольшое количество объявлений. **Повторяющиеся и похожие наборы, большое количество самых разных объявлений в селекторах - признак плохо организованного кода**. Пока бесконечный поиск и замена остаются вашим главным и единственным инструментом рефакторинга кода разметки - вы живете в камменном веке веб-технологий и еще даже не начинали верстать. 

## Абстрагируй все!

Что такое дизайн, если совсем кратко? **Дизайн - это «гайдлайн» - строгая система, набор стилевых правил и ограничений, перечень констант, аксиом и отношений в разметке и оформлении интерфейса, которым он неукоснительно должен соответсвовать.** Задача верстальщика в том чтобы правильно воспринять эту систему и максимально эфективно перевести ее с языка графических прототипов в работающий по заявленным требованиям код.

Поэтому маниакально абстрагируй все что только можно. Все что должно и может быть переиспользовано и любые конкретные значения, те, которые, когда-нибудь, но, в принципе, могут измениться. К примеру, на Stylus:

```stylus
// В @/stylus/utils/variables.styl:

$colors = {
  mint: #44c6a8,
  // ... другие конкретные значения цветов
}

// Создаем "основной цвет", абстрагируясь от конкретного цвета
$colors['primary'] = $colors.mint
// ... другие функциональные цвета
```

И теперь в любом месте где потребуется предоставить основной «брендовый» цвет:

```stylus
.selector
  color $colors.primary
```

Очевидно, что если весь остальной код будет аккуратно использовать правильную переменную - просто «по шелчку пальцев» возможно изменить этот основной цвет по всему интерфейсу! Все это логично и закономерно приводить нас к **идее некой общей «стилевой базы» интерфейса, которую очевидно способен нам предоставить препроцессор, и которую было бы удобно и правильно использовать даже для оформления максимально изолированных компонентов**.


## Структура и стилевая база препроцессора

Дальше я покажу определенную логичную и простую структуру организации файлов препроцессора, которую использую на проектах сам. Но вы можете что-то делать совсем иначе и, в результате, придти к совсем другой, удобной именно для ваших методов работы системе. Важно не следовать каким-то зазубренным до автоматизма теориям и якобы «лучшим практикам», а гибко и к месту применять возможности, и даже, вероятно - все время немного экспериментировать, стараясь расти и меняться к лучшему. Категорически важно только то, что **ваши стили должны быть действительно всегда четко и понятно организованы**.

На практике во многих командах «вытесняют» и игнорируют выгоду от более продвинутых и аккуратных подходов к разметке. Ведь это требует опреденных затрат на коммуникацию. Например, очень часто файлы стилей даже на препроцессоре - тупо и незамысловато «складируются в кучу» и практически никак не связаны друг-с-другом. Признайтесь себе наконец честно: даже хорошая подробная компонентность, хоть и позволяет решить проблему на самом примитивном физическом уровне, она вообще не рещает ее глобально, на уровне абстракций. Наоборот - **компонентность даже еще несколько затрудняет решение, так как строится именно на противоположных глобальности препроцессора, изолирующих подходах**. Ваша куча это попрежнему невыразительная невнятная неповоротливая куча, просто теперь она еще и разделена на множество подобных и глобально излишних куч, поменьше.

Но давайте уже организуем препроцессор, если с SCSS:

```
.
└─ sscs
   ├─ core // обшие и компилируемые сущности препроцессора
   │  ├─ _animations.scss // keyframes
   │  ├─ _base.scss // минимальная нормализация основных HTML-элементов
   │  ├─ _grid.scss // сетки
   │  ├─ _typography.scss // типографика
   │  └─ _utilities.scss // быстрые удобные классы-утилиты для включения прямо в разметку
   ├─ libraries // папка с файлами стилизаций сторонних модулей
   │  └─ _modal.scss - например какая-нибудь готовая модаль
   ├─ project // стили конкретного проекта
   │  ├─ _elements.scss // отдельные простые элементы-компоненты
   │  ├─ _fixes.scss // этот файл всегда должен быть практически пустой, исключая общеизвестные "проблемы браузеров"
   │  ├─ _layout.scss - стили общей для всех страниц GUI-обертки над контентом интерфейса
   │  └─ _widgets.scss - сложные составные комбинации простых элементов-компонентов
   ├─ utils // обшие и некомпилируемые основные сущности препроцессора
   │  ├─ _functions.scss // на практике нужны крайне редко
   │  ├─ _mixins.scss // параметризируемые и способные принимать контент примеси-микстуры
   │  ├─ _placeholders.scss // повторяющиеся наборы правил - растворы
   │  └─ _variables.scss // самый важный файл с переменными )
   ├─ _main.scss // точка сборки всех стилей препроцессора
   └─ _stylebase.scss // стилевая база
```

Тоесть, на самом деле - **порядок сборки всей кухни имеет значение**, конечно же:

```scss
// В @/scss/_stylebase.scss:
// Stylebase
//////////////////////////////////////////////////////
//////////////////////////////////////////////////////

// Uncompiled kitchen
@import "./utils/_functions";
@import "./utils/_variables";
@import "./utils/_mixins";
@import "./utils/_placeholders";

// Core base normal style and common utils
@import "./core/_animations";
@import "./core/_typography";
@import "./core/_grid";
@import "./core/_base";
@import "./core/_utilities";


// В @/scss/_main.scss:
// Project styles
//////////////////////////////////////////////////////
//////////////////////////////////////////////////////

// Stylebase for components
@import "_stylebase";

// App styles
@import "./project/_fixes";
@import "./project/_elements";
@import "./project/_widgets";
@import "./project/_layout";

/* External libraries customization */
@import "./libraries/_modal";
```

Итак, **«стилевой базой» мы будем называть некое основное ядро стилей, доступный всем остальным компонентам системы общий код препроцессора**. Более детально, он состоит из условно двух разных видов файлов:

1. Растворяемые при компиляции инструменты-помощники, сущности позволяющие генерировать лаконичный, оптимальный, связный код:
    1. **функции**
    2. **переменные**
    3. **параметризируемые примеси**
    4. **включения-плейсхолдеры**

2. Компилируемые глобальные стили:
    1. **анимации keyframes**
    2. **типографика**
    3. **сетки**
    4. **базовая нормализация основных HTML-элементов**
    5. **классы-помощники для разметки**

Удобно держать подобную минимальную «кухню» наготове в ваших стартовых проектах, чтобы с самого начала работы быстро настраивать стилизацию под конкретные требования и гайдлайн.

У меня вот, например, можно посмотреть - есть различные такие заготовки-«болванки» для быстрого старта на разных комбинациях актуальных технологий:
* [React c TypeScript и Stylus](https://github.com/ushliypakostnik/ts-react-stylus-i18next/tree/master/src/stylus)
* [Vue c SCSS](https://github.com/ushliypakostnik/vue-scss-i18next/tree/master/src/styles)
* [Webpack c SCSS и Nunjucks](https://github.com/ushliypakostnik/webpack-start/tree/master/src/scss)

## Адаптивная кухня

Стилевая база препроцессора призвана предоставлять все основные качества, константы гайдлайна и дизайна, например, такую важную его общую составляющую как типографика. Или, например - медиа-запросы для адаптивности в большинстве случаев используют одни и теже значения - «брейкпоинты» - точки перехода, значения ширины окна браузера, при которых один статичный «типоразмер» дизайна перестраивается в другой. **Признаком адаптивного дизайна как раз и является наличие нескольких таких статичных типоразмеров - диапазонов ширины экрана для которых не меняется пространственная раскладка, сетки и типографика на всем протяжении.** Что, по сути, и позволяет дизайнерам ловко покрыть «все случаи» с помощью нескольких макетов - по одному на каждый типоразмер.

Нужно не забывать, что кроме ньюансов при комплияции, **плейсхолдеры, в отличие от параметризированных миксинов не могут быть включены в медиа-запросы, но сами, при этом, могут их использовать**. Вот простейший обычный очень реалистичный кейс - создадим стили препроцессора для «резинового контейнера для контента с отступами по краям вдвое меньшими на мобильных чем на остальных экранах» - очень распространенной обычной обертки, которая часто переиспользуется по всему интерфейсу. Объявляем переменные брекпоинтов, делаем на них удобную для использования примесь принимающую контент в медиа-запросе, используем эту адаптивную примесь в плейсхолдере, и в конце-концов - растворяем этот набор в конкретной утилите-классе - только этот класс будет скомпилирован в результате:   

```stylus
// В @/stylus/utils/variables.styl:
// Project variables
//////////////////////////////////////////////////////
//////////////////////////////////////////////////////

// Sizes
//////////////////////////////////////////////////////

$gutter = 20px


// Breackpoints
//////////////////////////////////////////////////////

$breackpoints = {
  min: 320px,
  xs: 359px,
  sm: 768px,
  md: 1025px,
  lg: 1240px,
}

$breackpoints['xs-max'] = $breackpoints.sm - 1
$breackpoints['sm-max'] = $breackpoints.md - 1
$breackpoints['md-max'] = $breackpoints.lg - 1


// В @/stylus/utils/mixins.styl:
// Project mixins
//////////////////////////////////////////////////////
//////////////////////////////////////////////////////

// Media
//////////////////////////////////////////////////////
// Breackpoints in @/stylus/utils/variables.styl

$xs()
  @media only screen and (max-width $breackpoints.xs-max)
    {block}


// В @/stylus/utils/placeholders.styl:
// Project placeholders
//////////////////////////////////////////////////////
//////////////////////////////////////////////////////

// Rubber Container
$container
  width 100%
  padding-left $gutter
  padding-right $gutter

  +$xs()
    padding-left $gutter / 2
    padding-right $gutter / 2


// В @/stylus/core/utilities.styl:
// Project utilities
//////////////////////////////////////////////////////
//////////////////////////////////////////////////////

// Elements
//////////////////////////////////////////////////////

// Rubber Container
.container-fluid
  @extends $container
```

Теперь у этих элементов - будут одинаковые правильные адаптивные отступы по краям:

```html
<div id="element1">
  <div class="container-fluid"></div>
</div>

<div id="element2">
  <div class="container-fluid"></div>
</div>

<!-- Или можно даже так, но лучше, на самом деле, не надо: -->
<div id="element3" class="container-fluid"></div>
```

Код опять как будто выглядит излишне громозким, «не проще ли было просто написать все с медиа-запросом в классе» и все. Нет, это обманчиво. Я просто демонстрирую правильный ход мыслей и действий.  **В маштабе большого проекта неукоснительное следование принципам и правилам становиться категорически важным**.

На самом деле, нам осталось совсем немного для того чтобы «все понять про адаптивный дизайн». Давайте сделаем не «резиновый» контейнер - тоесть тянущийся на всю доступную ширину, а с фиксированной для каждого (у нас их 4) типоразмера шириной. По сути это и будет самая простая основная «рамочная» конcтрукция любого «адаптивного» дизайна.

Очевидно что ширина контейнера для контента на каждом типоразмере - несколько меньше чем его нижний брейкпоинт. А на мобильных элемент «становится резиновым». Добавим к кухне:

```stylus
// В @/stylus/utils/variables.styl:
// Project variables
//////////////////////////////////////////////////////
//////////////////////////////////////////////////////

// Sizes
//////////////////////////////////////////////////////

$container__lg = 1080px;
$container__md = 920px;
$container__sm = 700px;

// В @/stylus/utils/mixins.styl:
// Project mixins
//////////////////////////////////////////////////////
//////////////////////////////////////////////////////

// Media
//////////////////////////////////////////////////////
// Breackpoints in @/stylus/utils/variables.styl

$lg()
  @media only screen and (min-width $breackpoints.lg)
    {block}

$not-lg()
  @media only screen and (max-width $breackpoints.sm-max)
    {block}

$sm-and-md()
  @media only screen and (min-width $breackpoints.sm) and (max-width $breackpoints.md-max)
    {block}

$not-gadgets()
  @media only screen and (min-width $breackpoints.md)
    {block}

$gadgets()
  @media only screen and (max-width $breackpoints.sm-max)
    {block}

$md()
  @media only screen and (min-width $breackpoints.md) and (max-width $breackpoints.md-max)
    {block}

$sm()
  @media only screen and (min-width $breackpoints.sm) and (max-width $breackpoints.sm-max)
    {block}

$not-xs()
  @media only screen and (min-width $breackpoints.sm)
    {block}

$min()
  @media only screen and (max-width $breackpoints.xs)
    {block}

$landscape()
  @media only screen and (orientation: landscape)
    {block}

$portrait()
  @media only screen and (orientation: portrait)
    {block}


// В @/stylus/core/utilities.styl:
// Project utilities
//////////////////////////////////////////////////////
//////////////////////////////////////////////////////

// Elements
//////////////////////////////////////////////////////

// Rubber Container
.container
  @extends $container // раствор создан выше
  margin 0 auto // по центру

  +lg()
    max-width $container__lg

  +md()
    max-width $container__md

  +sm()
    max-width $container__sm
```

Так предоставляется простая удобная адаптивность. Набор примесей принимающих контент в медиа-запросах - дает нам надежный стандартизированный доступ к специфической стилизации элементов и виджетов в необходимом диапазоне размеров экранов, в любом месте кода препроцессора.

Но еще со времен когда я часто использовал Bootstrap 3, у меня остался пассаж с обычно осуждаемым), но на самом деле очень полезным в некоторых реальных ситуациях флагом **!important** [для простой быстрой стилизации посторонних модулей, которые выставлют стили инлайн через javascript, или тут, например - с ним надежнее], который предоставляет более «грубое и внешнее» решение - набор, созданных с помощью таких адаптивных примесей, утилитарных классов для принудительного включения прямо в разметку шаблонов:

```stylus
// В @/stylus/core/utilities.styl:
// Visibility utilities
//////////////////////////////////////////////////////

// stylelint-disable declaration-no-important
.visible--desktop,
.visible--gadgets,
.visible--tablet,
.visible--mobile,
.visible--desktop--inline-block,
.visible--gadgets--inline-block,
.visible--tablet-inline-block,
.visible--mobile--inline-block,
.visible--desktop--inline,
.visible--gadgets--inline,
.visible--tablet--inline,
.visible--mobile--inline
  display none !important

.visible--desktop
  +$not-gadgets()
    display block !important

.visible--gadgets
  +$gadgets()
    display block !important

.visible--tablet
  +$sm()
    display block !important

.visible--mobile
  +$xs()
    display block !important

.visible--desktop--inline-block
  +$not-gadgets()
    display inline-block !important

.visible--gadgets--inline-block
  +$gadgets()
    display inline-block !important

.visible--tablet--inline-block
  +$sm()
    display inline-block !important

.visible--mobile--inline-block
  +$xs()
    display inline-block !important

.visible--desktop--inline
  +$not-gadgets()
    display inline !important

.visible--gadgets--inline
  +$gadgets()
    display inline !important

.visible--tablet--inline
  +$sm()
    display inline !important

.visible--mobile--inline
  +$xs()
    display inline !important

.hidden--desktop
  +$not-gadgets()
    display none !important

.hidden--gadgets
  +$gadgets()
    display none !important

.hidden--tablet
  +$sm()
    display none !important

.hidden--mobile
  +$xs()
    display none !important
```
 
Дизайнеры склонны мыслить «статично», они обусловлены рамками размера макета и пропорции в которой рисуют. И поэтому, например, часто выставляют принудительные переносы в тексте, хотя лучше этого не делать, позоляя тексту перноситься «нативно», и ограничивая его только по максимальной ширине - в реальности экраны очень разные. Но если вам необходимо стравиться с таким поведением - не стоит игнорировать проблему с пробелом, особенно если заголовок отбит центрально, и очень удобно применить адаптивные классы прямо в HTML:
 
 ```html
<h2>Очень-очень длинный заголовок<br class="visible--mobile--inline" /><span class="hidden--mobile"> </span>с принидительным переносом на мобильных</h2>
``` 

В принципе, это все, что нужно знать для того чтобы начать делать хорошую адаптивную верстку.