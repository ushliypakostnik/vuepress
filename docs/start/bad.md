# Препроцессор

## Простейший пример плохого кода
Безобразного кода с каждым днем становится все больше, несмотря на то, что больнее и эпичнее всего страдают от этого сами авторы, горе-разработчики. И если определенную функциональность или рендер можно покрыть тестами, то ошибки оформления выявляются только «ручками».

Также, просто парадоксально, что все программисты слышали о простых основополагающих принципах качественного программирования [KISS](https://ru.wikipedia.org/wiki/KISS_(%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF)) и [SOLID](https://ru.wikipedia.org/wiki/SOLID_(%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)), но подавляющее большинство напрочь забывает о них, когда речь заходит об организации оформления, представления веб-интерфейса.

В реальной ситуации - заказчик, покупатель вашего кода в любой момент может захотеть внести любые правки, и вы должны быть максимально к этому готовы.

Давайте посмотрим на самый простейший пример плохого кода на CSS:

```css
/* Примитивнейший пример обычного плохого кода на CSS */

/* Где-нибудь в файлах стилей: */

.selector--1 {
  width: 200px;
  height: 200px;
  border: 1px solid #ADADAD;
  border-radius: 3px;
  /* ... и дальше еще огромное количество самых разных правил */
}

.selector--2 {
  width: 200px;
  height: 400px;
  border: 1px solid #ADADAD;
  border-radius: 3px;
  /* ... и дальше еще огромное количество самых разных правил */
}
```

Не делайте так больше почти никогда! ))) Почему? Код валидный, «в браузере все по макету», да и все именно так обычно и пишут. Но все и не «верстают как бог», правильно? В контексте любого проекта чуть большего чем совсем крохотный, подобный код «плохой и чреват проблемами в будущем». Он **конкретен и невыразителен, излишен, его сложно модифицировать и переиспользовать**.

## А как надо?

На сегодняшний день стандартной практикой для разработки CSS-кода является использование [Препроцессора](https://developer.mozilla.org/ru/docs/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C/CSS_preprocessor), который отнюдь не превращает формальную спецификацию CSS в язык программирования, но дает синтаксису необходимую силу и мощь, актуальные возможности и эффективность. Если говорить совсем просто, то без него, **очень многие требования современного веб-дизайна иначе было бы крайне затруднительно реализовать, особенно в масштабе крупных проектов**.  

Справедливости ради, нужно упомянуть, что последние годы, в связи с стремительным ростом популярности компонентных js-фреймворков и их подходов, все больше сторонников набирают также различные «CSS-in-JS»-реализации (например: [Styled Components](https://styled-components.com/)). Скоро, вероятно, можно будет спокойно использовать переменные в самом CSS ([CSS Custom Properties](https://developer.mozilla.org/ru/docs/Web/CSS/Using_CSS_custom_properties)). Тема холиварная, существуют контексты и ситуации когда подобный CSS-in-JS подход может оказаться более оправданным и изящным, без сомнения. И даже существует масса реалистичных кейсов когда проще всего будет действительно обойтись несколькими наборами правил на CSS, а любое его расширение будет излишним. Но в общем случае, в реальной коммерческой практике, имхо, для верстки сложных дизайнов и интерфейсов удобнее и эффективнее всего сейчас использовать любой препроцессор, **и, шок - даже с компонентным фреймворком**, дальше я планирую показать «как именно это лучше всего делать». Препроцессоры дают максимум возможностей и позволяют стремиться к максимальной выразительности и переиспользуемости. Вот во что превратился бы «плохой код» выше в SCSS-синтаксисе, наверное - самого популярного на сегодняшний день препроцессора - [Sass](https://sass-scss.ru/):
```scss
// В @/scss/utils/_variables.scss:

$selector__size: 200px;

$colors__border: #adadad;

$border-radius: 3px;


// В @/scss/utils/_placeholders.scss:
%border-block {
  border: 1px solid $colors__border;
  border-radius: $border-radius;
}


// В @/scss/utils/_mixins.scss:
@mixin size($width, $height) {
  width: $width;
  height: $height;
}


// В любом месте проекта:
.selector {
  &--1,
  &--2 {
    @extend %border-block;
    /* ... включение других сущностей препроцессора
      и специфическиих правил общих для селекторов */
  }

  &--1 {
    @include size($selector__size, $selector__size);
    /* ... включение других сущностей препроцессора
      и специфических правил уникальных для селектора */
  }

  &--2 {
    @include size($selector__size, ($selector__size * 2));
    /* ... включение других сущностей препроцессора
      и специфических правил уникальных для селектора */
  }
}
```

Точно тоже самое легко сделать и на, кажется, недооцененном, но очень удачном [Stylus](https://stylus-lang.com/) - совершенно не важно какой именно расширенный синтаксис вы используете, главное как и зачем. Очень много раз мне приходилось видеть плохой чужой код написанный якобы для препроцессора, видимо, «потому что так сейчас модно», но, на самом деле, практически ничем не отличающийся от кода CSS. Не делайте так! Препроцессор дает нам крайне ценную возможность абстрагировать общие качества гайдлайна, стиль и основанные на нем частные стили, организовать их намного более выразительно и лаконично, легко модифицировать и переиспользовать при необходимости.

В данном, вырванном из контекста, но, при этом, вполне жизненном примере, кажется, что кода препроцессора - сильно больше. Он еще и раскидан по нескольким разным файлам, что, как будто, еще все усложняет. Зачем так напрягаться, а? Прежде всего, привычка начинать писать разметку с переменных и обобщений - очевидно грамотная. Перестаньте плодить изолированные глухие кряки с магическими числами, начните применять абстракцию! Делайте хорошо сразу, потому что вы почти никогда и ничего не переделаете «потом», на самом деле. «Когда наш стартап наконец взлетит», и как раз во многом из-за такого отношения он может и не взлететь, в результате. Чем детализированнее и сложнее ваш интерфейс, его дизайн, тем больше строк и времени вы будете «экономить» просто оптимизируя общие наборы правил, переиспользуя стили. Кроме того, **поддерживать код и, тем более, вносить серьезные изменения будет на порядок проще**.

Первый пример демонстрирует что на начальных этапах развития проекта хорошо продуманного кода препроцессора может быть даже визуально несколько больше, чем неорганизаванного, внутренее плоского, скучного CSS. Но давайте разберем очень часто встречающийся кейс, в котором мы очевидно сразу сильно экономим много трафика и явно оптимизируем возможную поддержку. Такое очень часто встречается: нам нужно создать большое количество, предположим - 20 штук - модификаторов одного селектора - квадратной иконки размеров в 100 пикселей - и поставить в них нужные картинки в бекграунд. В Sass мы можем написать цикл с [интерполяцией](https://sass-scss.ru/documentation/sassscript/interpolyatsiya/) для создания селектора модификатора и указания пути до ресурса. И хотя такая синтаксическая возможность не является чем-то идейно решающе важным - на практике она экономит кучу времени и повышает качество жизни на работе: 

```scss
// В @/scss/utils/_variables.scss:

// Paths
$images__path--root: "../assets/images/";

// Sizes 
$icons__size: 100px;

// Views
$icons: 20;

// В любом месте проекта:
.icon {
  $image-path: "../../../" + $image_path--root + "icons/";

  @include size($icons__size, $icons__size); // эта примесь уже создана выше

  @for $i from 1 through $icons {
    &.icon--#{$i} {
      background: url("#{$image-path}icon--#{$i}.svg") center center no-repeat;
    }
  }
}
```
Пример предполагает что в вашем проекте следующая структура:

```
.
├─ assets
│  └─ images
│     ├─ icon--1.svg
│     ├─ icon--2.svg
│     └─ ...
└─ sscs
   └─ utils
      ├─ _mixins.scss
      └─ _variables.scss
```

Теперь в шаблонах мы можем использовать:

```html
<div class="icon icon--1"></div>
```

Если вы желаете чтобы картинки были с осмысленными именами - можете перебирать список:

```scss

.icon {
  $image-path: "../../../" + $image_path--root + "icons/";
  $images: "name1", "name2", "name3"; // Список имен

  @include size($icons__size, $icons__size);

  @each $image in $images {
    &.icon--#{$image} {
      background: url("#{$image-path}#{$image}.svg") center center no-repeat;
    }
  }
}
```

Ну и раз уж мы упомянули интерполяцию, необходимо вспомнить еще один простой кейс, который сейчас часто нужен и в котором вам она точно пригодится - «посчитать с переменной»:

```scss
.selector {
  $width: 100px;

  width: calc(100vw - #{$width});
}
```

Используйте на полную мощность и изучайте подробно свои ключевые инструменты. Используйте свой интеллект и фантазию. В хорошем коде препроцессора наборы правил не повторяются и какдый селектор содержит только небольшое количество объявлений. **Повторяющиеся и похожие наборы, большое количество самых разных объявлений в селекторах - признак плохо организованного кода**. Пока бесконечный поиск и замена остаются вашим главным и единственным инструментом рефакторинга кода разметки - вы живете в камменном веке веб-технологий и еще даже не начинали верстать!) 

## Абстрагируй все!

Что такое дизайн, если совсем кратко? **Дизайн - это «гайдлайн» - строгая система, набор стилевых правил и ограничений, перечень констант, аксиом и отношений в разметке и оформлении интерфейса, которым он неукоснительно должен соответсвовать.** Задача верстальщика в том чтобы правильно воспринять эту систему и максимально эфективно перевести ее с языка графических прототипов в работающий по заявленным требованиям код.

Поэтому маниакально абстрагируй все что только можно. Все что должно и может быть переиспользовано и любые конкретные значения, те, которые, когда-нибудь, но, в принципе, могут измениться. К примеру, на Stylus:

```stylus
// В @/stylus/utils/variables.styl:

$colors = {
  mint: #44c6a8,
  // ... другие конкретные значения цветов
}

// Создаем "основной цвет", абстрагируясь от конкретного цвета
$colors['primary'] = $colors.mint
// ... другие "функциональные" цвета
```

Любое имеющее глобальное значение и потенциально переиспользуемое качество гайдлайна и дизайна должно быть отражено в файле переменных препроцессора. Теперь в любом месте где потребуется предоставить основной «брендовый» цвет:

```stylus
.selector
  color $colors.primary
```

Очевидно, что если весь остальной код будет аккуратно использовать правильную переменную - просто «по шелчку пальцев» возможно изменить этот основной цвет по всему интерфейсу! Все это логично и закономерно приводить нас к **идее некой общей «стилевой базы» интерфейса, которую очевидно способен нам предоставить препроцессор, и которую было бы удобно и правильно использовать даже для оформления максимально изолированных компонентов**.


## Структура и стилевая база препроцессора

Дальше я покажу определенную логичную и простую структуру организации файлов препроцессора, которую использую на проектах сам. Но вы можете что-то делать совсем иначе и, в результате, придти к совсем другой, удобной именно для ваших методов работы системе. Важно не следовать каким-то зазубренным до автоматизма теориям и якобы «лучшим практикам», а гибко и к месту применять возможности, и даже, вероятно - все время немного экспериментировать, стараясь расти и меняться к лучшему. Категорически важно только то, что **ваши стили должны быть действительно всегда четко и понятно организованы**.

На практике во многих командах «вытесняют» и игнорируют выгоду от более продвинутых и аккуратных подходов к разметке. Ведь это требует опреденных затрат на коммуникацию. Например, очень часто файлы стилей даже на препроцессоре - тупо и незамысловато «складируются в кучу» и практически никак не связаны друг-с-другом. Признайтесь себе наконец честно: даже аккуратная подробная компонентность, хоть и позволяет решить проблему на самом примитивном физическом уровне, она вообще не рещает ее глобально, на уровне абстракций. Наоборот - **компонентность даже еще несколько затрудняет решение, так как строится именно на противоположных глобальности препроцессора, изолирующих подходах**. Ваша куча это попрежнему невыразительная невнятная неповоротливая куча, просто теперь она еще и разделена на множество подобных и глобально излишних куч, поменьше.

Но давайте уже организуем препроцессор, если с SCSS:

```
.
└─ sscs
   ├─ core // обшие и компилируемые сущности препроцессора
   │  ├─ _animations.scss // keyframes
   │  ├─ _base.scss // минимальная нормализация основных HTML-элементов
   │  ├─ _grid.scss // сетки
   │  ├─ _typography.scss // типографика
   │  └─ _utilities.scss // быстрые удобные классы-утилиты для включения прямо в разметку
   ├─ libraries // папка с файлами стилизаций сторонних модулей
   │  └─ _modal.scss - например какая-нибудь готовая модаль
   ├─ project // стили конкретного проекта
   │  ├─ _elements.scss // отдельные простые элементы-компоненты
   │  ├─ _fixes.scss // этот файл всегда должен быть практически пустой, исключая общеизвестные "проблемы браузеров"
   │  ├─ _layout.scss - стили общей для всех страниц GUI-обертки над контентом интерфейса
   │  └─ _widgets.scss - сложные составные комбинации простых элементов-компонентов
   ├─ utils // обшие и некомпилируемые основные сущности препроцессора
   │  ├─ _functions.scss // на практике нужны крайне редко
   │  ├─ _mixins.scss // параметризируемые и способные принимать контент примеси-микстуры
   │  ├─ _placeholders.scss // повторяющиеся наборы правил - растворы
   │  └─ _variables.scss // самый важный файл с переменными )
   ├─ _main.scss // точка сборки всех стилей препроцессора
   └─ _stylebase.scss // стилевая база
```

Тоесть, на самом деле - **порядок сборки всей кухни имеет значение**, конечно же:

```scss
// В @/scss/_stylebase.scss:
// Stylebase
//////////////////////////////////////////////////////
//////////////////////////////////////////////////////

// Uncompiled kitchen
@import "./utils/_functions";
@import "./utils/_variables";
@import "./utils/_mixins";
@import "./utils/_placeholders";

// Core base normal style and common utils
@import "./core/_animations";
@import "./core/_typography";
@import "./core/_grid";
@import "./core/_base";
@import "./core/_utilities";


// В @/scss/_main.scss:
// Project styles
//////////////////////////////////////////////////////
//////////////////////////////////////////////////////

// Stylebase for components
@import "_stylebase";

// App styles
@import "./project/_fixes";
@import "./project/_elements";
@import "./project/_widgets";
@import "./project/_layout";

/* External libraries customization */
@import "./libraries/_modal";
```

Итак, **«стилевой базой» мы будем называть некое основное ядро стилей, доступный всем остальным компонентам системы общий код препроцессора**. Более детально, он состоит из условно двух разных видов файлов:

1. Растворяемые при компиляции инструменты-помощники, сущности позволяющие генерировать лаконичный, оптимальный, связный код:
    1. **функции**
    2. **переменные**
    3. **параметризируемые примеси**
    4. **включения-плейсхолдеры**

2. Компилируемые глобальные стили:
    1. **анимации keyframes**
    2. **типографика**
    3. **сетки**
    4. **базовая нормализация основных HTML-элементов**
    5. **утилитарные классы-помощники для разметки**

Удобно держать подобную минимальную «кухню» наготове в ваших стартовых проектах, чтобы с самого начала работы быстро настраивать стилизацию под конкретные требования и гайдлайн.

У меня вот, например, можно посмотреть - есть различные такие заготовки-«болванки» для быстрого старта на разных комбинациях актуальных технологий:
* [React c TypeScript и Stylus](https://github.com/ushliypakostnik/ts-react-stylus-i18next/tree/master/src/stylus)
* [Vue c SCSS](https://github.com/ushliypakostnik/vue-scss-i18next/tree/master/src/styles)
* [Webpack c SCSS и Nunjucks](https://github.com/ushliypakostnik/webpack-start/tree/master/src/scss)

## Адаптивная кухня

Стилевая база препроцессора призвана предоставлять все основные качества, константы гайдлайна и дизайна, например, такую важную его общую составляющую как типографика. Или, например - медиа-запросы для адаптивности в большинстве случаев используют одни и теже значения - **брекпоинты** - точки перехода, значения ширины окна браузера, при которых один статичный **типоразмер** дизайна перестраивается в другой. **Признаком адаптивного дизайна как раз и является наличие нескольких таких статичных типоразмеров - диапазонов ширины экрана для которых не меняется пространственная раскладка, сетки и типографика на всем протяжении.** Что, по сути, и позволяет дизайнерам ловко покрыть «все случаи» с помощью нескольких макетов - по одному на каждый типоразмер.

Нужно не забывать, что кроме ньюансов при комплияции, **плейсхолдеры, в отличие от параметризированных миксинов, не могут быть включены в медиа-запросы, но сами, при этом, могут их использовать**. Давайте возьмем простейший обычный реалистичный кейс. Напишем стили препроцессора предоставляющие «резиновый контейнера для контента с отступами по краям вдвое меньшими на мобильных чем на остальных экранах». Обычно такой элемент не «обозначен явно», но на самом деле - подразумевается как обертка в любом адаптивном макете и часто переиспользуется по всему интерфейсу. Первым делом - объявляем переменную мобильного брекпоинта, создаем на ней удобную для использования стандартную примесь принимающую контент в медиа-запросе, используем эту адаптивную примесь в плейсхолдере для корректировки внутренних отступов, и в конце-концов - растворяем этот набор в конкретной утилите-классе. Только этот класс и будет скомпилирован в результате:

```stylus
// В @/stylus/utils/variables.styl:
// Project variables
//////////////////////////////////////////////////////
//////////////////////////////////////////////////////

// Sizes
//////////////////////////////////////////////////////

$gutter = 20px


// Breackpoints
//////////////////////////////////////////////////////

$breackpoints = {
  tablet: 768px,
}

$breackpoints['mobile--max'] = $breackpoints.tablet - 1


// В @/stylus/utils/mixins.styl:
// Project mixins
//////////////////////////////////////////////////////
//////////////////////////////////////////////////////

// Media
//////////////////////////////////////////////////////
// Breakpoints in @/stylus/utils/variables.styl

$mobile()
  @media only screen and (max-width $breackpoints.mobile--max)
    {block}


// В @/stylus/utils/placeholders.styl:
// Project placeholders
//////////////////////////////////////////////////////
//////////////////////////////////////////////////////

// Rubber Container
$container
  width 100%
  padding-left $gutter
  padding-right $gutter

  +$mobile()
    padding-left $gutter / 2
    padding-right $gutter / 2


// В @/stylus/core/utilities.styl:
// Project utilities
//////////////////////////////////////////////////////
//////////////////////////////////////////////////////

// Elements
//////////////////////////////////////////////////////

// Rubber Container
.container-fluid
  @extends $container
```

Теперь у этих элементов - будут одинаковые правильные адаптивные отступы по краям:

```html
<div id="element1">
    <div class="container-fluid"></div>
</div>

<div id="element2">
    <div class="container-fluid"></div>
</div>

<!-- Или можно даже так, но лучше, на самом деле, не надо: -->
<div id="element3" class="container-fluid"></div>
```

Код опять как будто выглядит излишне громозким, «не проще ли было просто написать все с медиа-запросом в классе и готово». Нет, это обманчиво, и если вы все еще мыслите так, то вам стоит либо совсем перестать читать, либо перечитать эту главу с самого начала. Я просто демонстрирую правильный ход мыслей и действий. Вы можете опираться на другие единицы измерения, написать все в каком-то немного другом синтаксисе, примеров в сети масса, но для быстрого и надежного адаптивного дизайна вам обязательно непреложно _нужно «что-то такое»_, нечто, предоставляющее возможность воздействовать на оформление через систему брекпоинтов и типоразмеров. Особенно полезно принять такое соглашение и стандартизацию при работе над проектом командой. **В масштабе большого проекта неукоснительное следование принципам и правилам становиться категорически важным**.

Справедливости ради, нужно упомянуть что Custom Properties «не умеют быть брекпоинтами», что, кажется, их нелепый минус, но современные спецификации пространственной раскладки [Grid](https://developer.mozilla.org/ru/docs/Web/CSS/CSS_Grid_Layout/Basic_Concepts_of_Grid_Layout) и [Flexbox](https://developer.mozilla.org/ru/docs/Learn/CSS/CSS_layout/Flexbox) умеют делать некоторые магические вещи с расладкой даже без медиа-запросов. В любом случае, использование современных нативных сеток в связке с описанным здесь адаптивным препроцессором и кажется самым эффективным подходом.

На самом деле, нам осталось совсем немного для того чтобы «все понять про адаптивный дизайн». Давайте сделаем не «резиновый» контейнер - тоесть тянущийся на всю доступную ширину, а с фиксированной для каждого типоразмера шириной. Пусть в нашем дизайне только три типоразмера: все лэптопы-ноуты, таблетки и мобилы. По сути это и будет самая простая основная «рамочная» конcтрукция любого «адаптивного» дизайна.

Очевидно, что ширина контейнера для контента для каждого типоразмера - несколько меньше чем его нижний брекпоинт. А на мобильных элемент «становится резиновым». Добавим к кухне:

```stylus
// В @/stylus/utils/variables.styl:
// Project variables
//////////////////////////////////////////////////////
//////////////////////////////////////////////////////

// Sizes
//////////////////////////////////////////////////////

$container__desktop = 1080px;
$container__tablet = 700px;


// Breackpoints
//////////////////////////////////////////////////////

$breackpoints = {
  tablet: 768px,
  desktop: 1240px,
}

$breackpoints['tablet--max'] = $breackpoints.desktop - 1


// В @/stylus/utils/mixins.styl:
// Project mixins
//////////////////////////////////////////////////////
//////////////////////////////////////////////////////

// Media
//////////////////////////////////////////////////////
// Breakpoints in @/stylus/utils/variables.styl

$desktop()
  @media only screen and (min-width $breackpoints.desktop)
    {block}

$gadgets()
  @media only screen and (max-width $breackpoints.tablet--max)
    {block}

$tablet()
  @media only screen and (min-width $breackpoints.tablet) and (max-width $breackpoints.tablet--max)
    {block}

$not-mobile()
  @media only screen and (min-width $breackpoints.tablet)
    {block}

$landscape()
  @media only screen and (orientation: landscape)
    {block}

$portrait()
  @media only screen and (orientation: portrait)
    {block}


// В @/stylus/core/utilities.styl:
// Project utilities
//////////////////////////////////////////////////////
//////////////////////////////////////////////////////

// Elements
//////////////////////////////////////////////////////

// Rubber Container
.container
  @extends $container // раствор создан выше
  margin 0 auto // по центру

  +lg()
    max-width $container__desktop

  +sm()
    max-width $container__tablet
```

Так предоставляется простая удобная адаптивность. Набор примесей принимающих контент в медиа-запросах - дает нам надежный стандартизированный доступ к специфической стилизации элементов и виджетов в необходимом диапазоне размеров экранов, в любом месте кода препроцессора.

Но, кроме этого, еще со времен когда я часто использовал Bootstrap 3, у меня остался формирующий удобные утилиты пассаж с обычно огульно осуждаемым, но на самом деле очень полезным в некоторых реальных ситуациях флагом **!important** [для простой быстрой стилизации сторонних модулей, которые выставлют стили инлайн через javascript, или тут, например - с ним надежнее]. Этот код предоставляет более «грубое и внешнее» решение - набор, созданных с помощью наших стандартных адаптивных примесей, утилитарных классов для принудительного включения прямо в разметку шаблонов:

```stylus
// В @/stylus/core/utilities.styl:
// Visibility utilities
//////////////////////////////////////////////////////

// stylelint-disable declaration-no-important
.visible--desktop,
.visible--gadgets,
.visible--tablet,
.visible--mobile,
.visible--desktop--inline-block,
.visible--gadgets--inline-block,
.visible--tablet-inline-block,
.visible--mobile--inline-block,
.visible--desktop--inline,
.visible--gadgets--inline,
.visible--tablet--inline,
.visible--mobile--inline
  display none !important

.visible--desktop
  +$not-gadgets()
    display block !important

.visible--gadgets
  +$gadgets()
    display block !important

.visible--tablet
  +$sm()
    display block !important

.visible--mobile
  +$xs()
    display block !important

.visible--desktop--inline-block
  +$not-gadgets()
    display inline-block !important

.visible--gadgets--inline-block
  +$gadgets()
    display inline-block !important

.visible--tablet--inline-block
  +$sm()
    display inline-block !important

.visible--mobile--inline-block
  +$xs()
    display inline-block !important

.visible--desktop--inline
  +$not-gadgets()
    display inline !important

.visible--gadgets--inline
  +$gadgets()
    display inline !important

.visible--tablet--inline
  +$sm()
    display inline !important

.visible--mobile--inline
  +$xs()
    display inline !important

.hidden--desktop
  +$not-gadgets()
    display none !important

.hidden--gadgets
  +$gadgets()
    display none !important

.hidden--tablet
  +$sm()
    display none !important

.hidden--mobile
  +$xs()
    display none !important
// stylelint-enable declaration-no-important
```
 
Дизайнеры склонны мыслить «статично», они обусловлены рамками размера макета и пропорции в которой рисуют. И поэтому, например, часто выставляют принудительные переносы в тексте, хотя лучше этого не делать, позоляя тексту переноситься «нативно», и ограничивая его только по максимальной ширине - **в реальности экраны очень разные**. Но если вам необходимо стравиться с таким поведением - не стоит игнорировать проблему с пробелом, особенно если заголовок отбит центрально, и очень удобно применить адаптивные классы прямо в HTML:
 
 ```html
<h2>Очень-очень длинный заголовок<br class="visible--mobile--inline" /><span class="hidden--mobile"> </span>с принидительным переносом на мобильных</h2>
``` 

В принципе, это все, что нужно знать у уметь для того чтобы начать делать хорошую адаптивную верстку.

## Типографика

Спросите любого нормального дизайнера: «Что в стиле и оформлении веб-интерфейса (тоесть в UI, а не в UI/UX) самое главное?». Думаю, многие ответят: «Типографика». Многим заказчикам и пользователям нравятся «рюшечки и котики», или, очень важно - **на самом деле ваша верстка должна быть уверено доступна с клавиатуры без мыши, или даже для слабовидящих людей**. Но все же, типографика и текстовый контент категорически важны, и должны быть с перманентно одинаковым оформлением и хорошо читаемы, по крайней мере.

Сейчас мы организовали препроцессор, его стилевую базу и добавили в нее стандартный инструментарий для адаптивности. Давайте сделаем типографику, такую чтобы можно было как в истории рассказаной во вступлении к этому пособию «вообще все контролировать». Тут я тоже обычно использую подход «как в Bootstrap 3» на базовом кегле в пикселях [потому что в макетах оно именно в пикселях], предположим что у нас есть всего три основных кегля и два начертания шрифта, пишем на SCSS:

```scss
// В @/src/scss/core/_typography.scss:
// Typographic variables
//////////////////////////////////////////////////////

// Good line-height and letter-spacing
$line-height_base: 1.428571429;
$normal-letter-spacing: normal;

// Guide

$font-size--base: 16px;
$font-size__coefficient--large: 2.5;
$font-size__coefficient--normal: 1.5;
$font-size__coefficient--small: 1;

$font-size--large: round($font-size--base * $font-size__coefficient--large); // 40px
$font-size--normal: round($font-size--base * $font-size__coefficient--normal); // 24px
$font-size--small: round($font-size--base * $font-size__coefficient--small); // 16px

$line-height--computed: round($font-size--base * $line-height--base);
$line-height--large: floor($line-height--computed * $font-size__coefficient--large); // 55px
$line-height--normal: floor($line-height--computed * $font-size__coefficient--normal); // 35px
$line-height--small: floor($line-height--computed * $font-size__coefficient--small); // 23px

$font-family__sans: Helvetica, Arial, sans-serif;
$font-weight__sans__regular: 400;
$font-weight__sans__bold: 700;
```

Я думаю, тут все просто и понятно - мы используем базовый кегль, коэфициенты для основных кеглей из гайда, и стандартный коэфициент для интерлиньяжа, «хорошей высоты строки». И вот тут - давайте сделаем стандартную примесь которую будем использовать повсеместно. Для отдачи типографики во все текстовые поля интерфейса:  

```scss
// Universal Typographic Mixin
//////////////////////////////////////////////////////

// We use one, only one, Karl, a universal mixin for all cases !!!!!!!!!!

@mixin text($font-family, $font-size, $font-weight) {
  font-family: $font-family;
  font-size: $font-size;
  font-weight: $font-weight;
  letter-spacing: $normal-letter-spacing;

  @if $font-size == $font-size--large {
    line-height: $line-height--large;
  } @else if $font-size == $font-size--normal {
    line-height: $line-height--normal;
  } @else if $font-size == $font-size--small {
    line-height: $line-height--small;
  } @else {
    line-height: floor($font-size * $line-height--base);
  }
}
```
Теперь, если вам нужно, например, изменить какой-то стандартный кегль для определенного типоразмера (так очень часто бывает), вы можете сделать это для всего интерфейса с помощью включения адаптивной примеси прямо в «единую примесь для типографики». Просто добавим переменную и условие в примесь:
 
```scss
$font-size__coefficient--large--mobile: 2;

@mixin text($font-family, $font-size, $font-weight) {
  @if $font-size == $font-size--large {
    @include xs {
      font-size: round($font-size--base * $font-size__coefficient--large--mobile); // 32px
      line-height: floor($line-height--computed * $font-size__coefficient--large--mobile);// 46px
    }
  }
}
```

В случаях когда необходимо передать специфическую высоту строки, такое правило передается после универсальной примеси:

```scss
// В любом месте проекта:
.selector {
  @include text($font-family_sans, $line-height_small, $font-weight_sans_bold);
  line-height: 17px;
}
```

Мы можем раздать стандартную типографику по заголовкам, в параграф, а также сделать утилиту для включения прямо в разметку:

```scss
// Base Typographic
//////////////////////////////////////////////////////

p {
  margin-bottom: $gutter / 2;
  @include text($font-family__sans, $font-size--small, $font-weight__sans__regular);

  // Можно применить адаптивную примесь чтобы изменить поведение более локально - только для этих элемента
  @include xs {
    @include text($font-family__sans, $font-size--small * 1.2, $font-weight__sans__regular;
  }
}

h1, h2 {
  @include text($font-family__sans, $font-size--large, $font-weight__sans__bold);
}

h3, h4 {
  @include text($font-family__sans, $font-size--normal, $font-weight__sans__bold);
}

h5, h6 {
  @include text($font-family__sans, $font-size--small, $font-weight__sans__bold);
}

strong {
  font-weight: $font-weight__sans__bold;
}

.text {
  &--large {
    @include text($font-family__sans, $font-size--large, $font-weight__sans__bold);
  }

  &--normal {
    @include text($font-family__sans, $font-size--small, $font-weight__sans__bold);
  }

  &--small {
    @include text($font-family_sans_ui, $font-size_small, $font-weight_sans-ui_regular);
  }

  &--center {
    text-align: center;
  }
}
```

Дальше уже опять начинается, с одной стороны, фантазия и творчество, а с другой, во многом - конкретные требования проекта, гайдлайна, макетов. Просто вы должны начать **неукоснительно использовать стандартизированные подходы и абстракции**. Во всем.

Здесь можно посмотреть как точно такая же управляемая минимальная типографическая кухня реализована [на Stylus](https://github.com/ushliypakostnik/ts-react-stylus-i18next/blob/master/src/stylus/core/typography.styl).

## Нормализация

В современных условиях верстая только для modern bro, вы можете не заморачиваться каким-то специальным сбросом-нормалайзом и использовать для этих целей специальный файл стилевой базы, например [на SCSS](https://github.com/ushliypakostnik/vue-scss-i18next/blob/master/src/styles/core/_base.scss) или [на Stylus](https://github.com/ushliypakostnik/ts-react-stylus-i18next/blob/master/src/stylus/core/base.styl).

Содержание этого файла должно быть крайне минималистиченым, очень аккуратным. Базовая нормализация основных HTML-элментов, стили для html и body, блоки. Нестандартное поведение. Какие-то специфические элементы, например - плейсхолдеры.

```scss
// No outline on focus controls!!!
button,
input,
textarea,
a {
  // stylelint-disable-next-line declaration-no-important
  outline: none !important;

  &:hover,
  &:active,
  &:focus {
    // stylelint-disable-next-line declaration-no-important
    outline: none !important;
  }
}
```

Стили здесь, это то что должно быть точно и вообще везде! Не наносите никакое оформление и кастомизацию с помощью этих правил (только на **\<body>** и **\<html>**)! Нормализуйте и готовьте! Пока лишним будет объяснять почему, но это особенно важно если вы собираетесь использовать описанные здесь подходы с компонентным фреймворком.

## Стиль кода, номенклатура и композиция

Окончательно стало необходимо поговорить о том, о чем бы я поговорил с самого начала, если бы это был сухой технический гайд. О стиле кода, номенклатуре имен и композиции. Вместо того чтобы разводить бессмысленные холивары о «табах и пробелах», я советую просто использовать на любых проектах [EditorConfig](https://editorconfig.org/) и линтеры. В контексте содержания этого раздела собственно [stylelint](https://stylelint.io/). Да, линтеры это бесячие штуки, понятно, «вам все время не до этого», «баги горят», «боссы-заказчики рвут и мечут», но только они позволяют легко поддерживать ваш, например - общий командный код - в священной кристальной чистоте и красоте. Настроить Stylelint «под себя», это, на самом деле, совсем недолго - вечер, и даже по-своему интересно-занимательно, если вы цените свои инструменты. Сейчас я используют вот такой [конфиг Stylelint для SCSS](https://github.com/ushliypakostnik/webpack-start/blob/master/.stylelintrc).

### Именование
Имена записываются в нижнем регистре.
Именнование должно быть:
* надежно уникальным;
* осмысленным и легко интуитивно-понятным;
* как можно более лаконичным, при этом.

При именовании селекторов по классу и идентификаторов, составных частей компонентов, элементов, блоков и их модификаторов, удобно применять **формальный БЭМ-подход, стиль Two Dashes**:

```scss
.block__element--modifier {
  ...
}
```

Возможности сложной композиции, наличие каскадирования и Parent Selector ([в SCSS](https://sass-lang.com/documentation/style-rules/parent-selector), [в Stylus](https://stylus-lang.com/docs/selectors.html#parent-reference)) в синтаксисах препроцессоров к этому крайне располагает:

```scss
.block {
  &__element {
    &--modifier {
      ...
    }
  
    // Сделать стили для элемента .block__element-wrapper
    &-wrapper {
      ...
    }
  }
}
```

Или, даже так, при необходимости, хотя это не и «не по БЭМ»:

```scss
.block {
  ...

  // Сделать специфические стили для .block внутри .wrapper
  .wrapper & {
    ...
  }
}
```

Но на самом деле, полностью невозможно избежать использования простых имен-утилит, классов-модификаторов для логики или даже составных селекторов с голыми тагами. Например, все еще вы используете какой-нибудь громозкий Bootstrap или другие стороннии модули поскромнее - такие имена будут прокрадываться в ваш код из этих библиотек и решений. Или просто, предположим - верстаете быстрый прототип.

```scss
// класс-модификатор, но стандартной неспецифической анимации
.block.--fade-on {
  ...
}

// простой переиспользуемый элемент-утилита внутри блока
.block .overlay {
  ...
}

// быстрая конструкция для проверки гипотезы при прототипировании, например
.block ul > li {
  ...
}
```

Неоправданно раздутые стили, в которых множество идентификаторов описывают, содержат одно и то же, перегруженный классами HTML — в некоторых ситуация тоже может быть не уместным и не адекватным подходом (прототип, например). **Если необходимо выразить уникальность и обеспечить независимость чего-либо - следует создавать селекторы по БЭМ; если что-то заурядно, единобразно повсюду и может быть переиспользованно или вероятно будет измененно — лучше не перегибать палку**.

Предположим, нам необходимо разметить простую страницу-лендинг, содержащую два баннера-секции с несколькими простыми элементами внутри: заголовком, параграфом текста и CTA-кнопкой действия. В таком случае нам требуются всего три «БЭМ-идентификатора»: «блока» - страницы и двух эго «элементов» - баннеров, во всех остальных случаях, для остальной разметки мы впоне можем обойтись семантикой голых тегов с готовой общей типографикой (**\<h2>**, **\<p>**) и простыми классом элементом общим для всего интерфейса (**.button**):

```html
<main class="page page-name" role="main">

    <section class="banner page-name__banner--1">
        <h2>Заголовок 1</h2>
        <p>Текст 1 ...</p>
        <a href="#" class="button">Перейти</a>
    </section>

    <section class="banner page-name__banner--2">
        <h2>Заголовок 2</h2>
        <p>Текст 2 ...</p>
        <a href="#" class="button">Перейти</a>
    </section>

</main>
```

Код препроцессора:

```scss
// Дефолтная типографика проекта в @/src/scss/core/_typography.scss:

h2 {
  ...
}

p {
  ...
}

// Элементы проекта в @/src/scss/project/_elements.scss:

// Обычная кнопка
.button {
  ...
}

// Виджеты проекта в @/src/scss/project/_widgets.scss:

// Страницы - общее
.page {
  ...
}

// Баннеры - обшее
.banner {
  ...
}

// Конкретный макет - в @/src/scss/project/_page-name.scss:
.page-name {
 
  // Первый баннер макета
  &__banner--1 {
    ...
  }

  // Второй баннер макета
  &__banner--2 {
    ...
  }
}
```

Теперь мы можем влиять на поведение эдементов и голых тегов с помощью трёх оберток с надежно именованными индентификаторами.

Также важными кажутся соглашения о выборе имен переменных и других сущностей препроцессора:
* имена переменных чаще всего состоят из смысловых блоков-маркеров определяющих разные сущности которые контролирует переменная, для разделения таких частей используется двойное нижнее подчеркивание (_) или двойной дефис (--);
* для разделения маркеров в имени переменной, обозначающих одну сущность, например, свойство CSS, используется дефис (-).

```scss
// В @/scss/utils/_variables.scss:
// Elements
//////////////////////////////////////////////////////

// Sizes and rounding
//////////////////////////////////////////////////////

$border-radius__small: 7px;

$controls__height: 70px;
$controls__height--mobile: 50px;


// Buttons

$buttons__border-radius: $border-radius__small;

$buttons__height: $controls__height;
$buttons__height--mobile: $controls__height--mobile;
```

Подобные подходы удобно применять и для выбора имен других сущностей препроцессора - растворов-плейсхолдеров и параметризированных примесей или утилит. Или даже тот же самый подход, что и с поменклатурой селекторов по классу, «по БЭМ, Two Dashes»:

```scss
// В @/scss/utils/_variables.scss:

$colors__black: #000000;
$colors__white: #ffffff;


// В @/scss/utils/_placeholders.scss:

%background {
  &--black {background: $colors__black}

  &--white {background: $colors__white}
}


// В @/scss/utils/_utilities.scss:
.background {
  &--gray {@extend %background--black}
    
  &--white {@extend %background--white}
}
```

### Композиция

Я думаю что вам уже стало понятно, что невзирая на существующее сегодня в среде разработчиков серьезное предубеждение, я предлагаю активно, но при этом аккуратно, использовать удобный базовый функционал препроцессора — **каскадирование**. Если необходимо, и наглядно, в плане выразительности кода препроцессора в development-проекте, и технически, в плане содержания и надёжности скомпилированных стилей на production, **обозначить зависимость чего-либо от чего-либо** — можно просто вложить одно в другое.

Вкладывать селекторы можно и нужно в следующих основных случаях:

**1.** Естественные случаи: конструкции которые нельзя ломать, например, списки и сетки, семантичные голые теги [внутри родительских идентификаторов, без которых они бесполезны], например, при быстром прототипировании:
```scss
.menu {
  ul {
    > li {
      > a {
        ...
      }
    }
  }
}

.grid {
  > div {
    ...
  }
}
```

**2.** Псевдоклассы, псевдоэлементы, элементы, состояния-модификаторы, адаптивные примеси принимающие контент в медиа-запросах - для каждого селектора. Стараемся держать всю информацию о каждом компоненте, виджете, элементе — в одном месте, это очень удобно и наглядно.
```scss
.selector {
  &:hover,
  &::before,
  &__element,
  &--modifier {
    ...
  }

  @include mobile {
    ...
  }
}
```
**3.** Иногда все-таки приходится вкладывать селекторы в более внешние обёртки, классы-абстракции. Это позволяет отделять и защищать стили для отдельных частях системы разметки, влиять на более мелкие компоненты: конструкций сетки, виджеты, утилиты.
```scss
// Смотря где удобнее и логичнее это сделать -
// в самом селекторе перед parent или просто в обертке:

.selector {
  .wrapper & {
    ...
  }
}

.wrapper {
  .selector {
    ...
  }
}
```

Теперь, чтобы всё стало окончательно прозрачно и понятно, приведём еще один простой наглядный пример. Предположим, что в макетах страницы с банерами, которую мы рассмотрели чуть выше, для каждого блока-баннера нестандартным специфичекским образом меняется типографика в зависимости от типоразмера экрана. Как лучше всего организовать разметку стилей и медиа-запросы в ней? Наверное никто не захочет делать это вот так — совершенно безобразно — очень много кода и медиа-запросов в нём:

```scss
.page-name {
  &__banner--1 {
    h2 {
      ...

      @include tablet {
          ...
      }

      @include mobile {
          ...
      }
    }

    p {
      ...
    }

    .btn {
      ...
    }
  }


  &__banner--2 {
    ...
  }
}
```

Вот так тоже будет не очень удобно, хотя этот вариант реализует более классический подход с минимумом медиа-запросов в коде:

```scss
.page-name {
  &__banner--1 {
    ...
  }

  &__banner--2 {
    ...
  }

  @include tablet {
    &__banner--1 {
      ...
    }

    &__banner--2 {
      ...
    }
  }

  @include mobile {
    &__banner--1 {
      ...
    }

    &__banner--2 {
      ...
    }
  }
}
```

Для данного простого примера нужно организовать включение стилей для других типоразмеров вот так — каждый селектор баннера содержит всю информацию о нём в максимально понятной и удобной форме:

```scss
.page-name {
  &__banner--1 {
    ...

    @include tablet {
      ...
    }

    @include mobile {
      ...
    }
  }

  &__banner--2 {
    ...
  
    @include tablet {
      ...
    }
  
    @include mobile {
      ...
    }
  }
}
```

Теперь поговорим о еще более абстрактных правилах, для которых невозможно насторить линтер, но которым я стараюсь следовать:

* локальные переменные объявляются (или глобальные переодределяются) перед любыми объявлениями и отделяются от деклараций новой строкой;
* примешивания растворов идут после переменных перед всеми объявлениями свойств;
* примешивания параметризированных микстур [даже если примесь не принимает параметров] идут после деклараций, исключение составляют случаи когда требуется локально для данного селектора перекрыть свойство объявленное в примеси;
* сортировка правил осуществляется не по алфавиту, в случайном порядке, но, возможно, нестрого ориентируясь на концепцию [Concentric-CSS](https://github.com/brandon-rhodes/Concentric-CSS);
* вложенные селекторы и директивы, содержащие собственные объявления, всегда идут после новой строки (но если родительский тег не содержит собственных правил [и хочется по каким-то причинам сохранить уровень вложенности] пустую строку перед дочерним селектором можно опустить) в последовательности:
    1. псевдоклассы;
    2. псевдоэлементы;
    3. вложенные дочерние селекторы;
    4. вложенные дочерние селекторы-модификаторы;
    5. вложенные утилиты;
    6. родительские, по отношению к данному, селекторы перед (&);
    7. примеси с @content и медиа-запросы (медиа-запросы в стандартном случае имеют вид такой примеси);

```scss
// Глобальные переменные в @/scss/utils/_variables.scss:
$variable--1: value;


// Сборник миксинов проекта в @/scss/utils/_mixins.scss:
@mixin mixin-name($variable1, $variable2) {
  property--1: $variable1;
  property--2: $variable2;
}


// Сборник растворов проекта в @/scss/utils/_placeholders.scss:
%placeholder-name {
  property--3: value;
  property--4: $variable--3;
}


// В любом месте проекта:
.selector {
  // Переменные
  $variable--2: value;
  $variable--3: value;

  // Растворы
  @extend %placeholder-name;
  // Правила
  property--5: value;
  property--6: value;
  // Примеси
  @include mixin-name($variable--2, $variable--3);
  property--2: value; // исключение - переписываем свойство в примеси

  // Псевдоклассы
  &:hover {
    ...

    a {color: $variable-03;} // допустимо на одной строке, если одно правило
  }

  // Псевдоэлементы
  &::after {
    ...
  }

  // Дочерние селекторы
  &__element {
    ...
  }

  // Модификаторы
  &--modifier {
    ...
  }

  // Утилиты
  .utility {
    ...
  }

  // Примеси с @content
  @include mixin-02 {
    @content;
  }

  // Родительские обертки перед &
  .wrapper & {
    ...
  }
}
```

### Комментирование

Старайтесь оставлять комментарии к каждому нетривиальному или специфическому месту, которое потенциально способно вызвать затруднения, когда вы сами или кто-то другой вдруг столкнется с этим в будущем.

* для комментирования используется только однострочный тип комментария начинающийся с двух слешей (//);
* комментарий к селектору идёт на строчке непосредственно перед ним, комментарий к группе селекторов отбивается пустой строкой;
* комментарий к селектору, группе селекторов, разделу кода располагается на отдельной строке, комментарий к свойству - на той же строке что и комментируемое объявление через пробел после него;
* комментарий к разделу отбивается двумя пустыми строками сверху, одной строкой или двумя (заголовок файла или очень большого-важного фрагмента) строками с большим количеством слешей и пустой строкой снизу.

```scss
// Это селектор
.selector {
  property: value; // комментарий к свойству
  ...
}

// А это селекторы

.selector1 {
  ...
}

.selector2 {
  ...
}


// Sizes
//////////////////////////////////////////////////////

// Main
$gutter: 32px;


// Раствор для усечения и добавления многоточия
// в слишком длинную строку на одной строке
// 1. Предотвращает сворачивание содержимого, оставляет его на одной строке.
// 2. Добавляет многоточие на конце строки.
%string-overflow-protection {
  white-space: nowrap; // 1
  text-overflow: ellipsis; // 2
  overflow: hidden;
}


// Примесь для выставления размера блоку
// @author Левон Гамбарян
//
// @param {Length} $width - ширина элемента
// @param {Length} $height - высота элемента
//
// @example usage:
// .selector {
//   @include size(100%, 200px);
// }
//
// @example output:
// .selector {
//   width: 100%;
//   height: 200px;
// }
@mixin size($width, $height) {
  width: $width;
  height: $height;
}
```

## Компонентность

Мы выделяем некую сущность в отдельный компонент, когда это:
* описывает, обслуживает какую-то отдельную определённую функциональность;
* может быть использовано повторно и/или модифицировано;
* отношения с другими компонентами чётко определены.

При ипользовании компонентных фреймворков с препроцессорами крайне соблазнительной и сильной оказывается идея предоставить стилевую базу компонентам. Таким образом мы решаем сразу все проблемы - получая и мощную глобальную абстракцию препроцессора и лаконичную оптимальную инкапсуляцию частных стилей в компонентах. Пока я заметил только один незначительный минус этого подхода - в dev-режиме во вкладке инспектора которая отображает свойства применённые к текущему выбранному элементу - происходит сильное наслоение дублирующихся свойств и пользоваться ей становится неудобно. С другой стороны вы должны писать так идеально, чтобы у вас вообще не возникало такой необходимости.) 

### Vue

Давайте посмотрим как это будет с замечательным Vue, позволяющим максимально наглядно и удобно формировать **однофайловые компоненты**, которые содержат всю разметку, необходимую ей логику и кастомизацию в одном месте:

```vue
<template>
...
</template>

<script>
export default {
...
};
</script>

<style lang="scss" scoped> /* scoped-стили - только для этого компонента */
  @import "@/scss/_stylebase.scss"; /* вот эта строчка решает все проблемы */

  /* Локальные переменные компонента (и миксины если нужно) */
  $component__variable--1: value;
  $component__variable--2: value;

  .component {
    /* Растворы, правила, примеси */
    @extend %placeholder;
    property-01: value;
    property-02: value;
    @include mixin--1($component__$variable--1);

    /* Дочерние селекторы */
    &__element {
      ...
    }

    /* Модификаторы */
    &--modifier {
      ...
    }

    /* Примеси с @content */
    @include mixin--2() {
      @content;
    }
  }
</style>
```

Vue позволяет защитить стили компонента через атбрибут **scoped**, захешировав и полностью изолировав их. Правда, это не всегда получается: исключение составляют компоненты являющиеся обертками над сторонними модулями, иногда со специфической проблемной кастомизацией и, на самом деле, любые компоненты, использование которых другими компонентами затрудняет **scoped**.

### React

С React все более прозаично - у нас просто есть папка **@/scss/components/** в которой мы складируем стили отдельных компонентов, которые, если это необходимо - используют стилевую базу. Вот - самый простой компонент - Loader, для примера, стили:

```scss
// @/src/scss/component/utils/_loader.scss
// Loader
//////////////////////////////////////////////////////
//////////////////////////////////////////////////////

// подтягиваем стилевую базу, если нужно, здесь - ради основного цвета
@import "../../_stylebase.scss";

.loader {
  $loader_size_default: 100px;
 
  @include size($loader_size_default, $loader_size_default);

  svg path {
    fill: $color_primary;
  }
}
```

Сам компонент, в **@/src/components/utils/Loader.jxs**:

```jsx harmony
import React from "react";
import PropTypes from "prop-types";

import '../../scss/components/utils/_loader.scss'; // подтягиваем стили компонента

const Loader = ({size}) => {
  return (
    <div className="loader">
      <svg
        version="1.1"
        xmlns="http://www.w3.org/2000/svg"
        x="0px"
        y="0px"
        width={size}
        height={size}
        viewBox={`0 0 ${size / 2} ${size / 2}`}>
        <path
          fill="#000"
          d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z">
          <animateTransform
            attributeType="xml"
            attributeName="transform"
            type="rotate"
            from="0 25 25"
            to="360 25 25"
            dur="0.4s"
            repeatCount="indefinite"/>
        </path>
      </svg>
    </div>
  );
};

Loader.defaultProps = {
  size: 100,
};

Loader.propTypes = {
  size: PropTypes.number,
};

export default Loader;
```