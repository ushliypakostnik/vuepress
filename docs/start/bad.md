# Препроцессор

## Простейший пример плохого кода
Безобразного кода с каждым днем становится все больше, несмотря на то что больнее всего страдают от него сами авторы, горе-разработчики. И если определенную функциональность или рендер можно покрыть тестами, то ошибки оформления выявляются только «ручками».

Также, просто парадоксально, что все программисты слышали о простых основополагающих принципах качественного программирования [KISS](https://ru.wikipedia.org/wiki/KISS_(%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF)) и [SOLID](https://ru.wikipedia.org/wiki/SOLID_(%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)), но подавляющее большинство напрочь забывает о них, когда речь заходит об организации оформления, представления веб-интерфейса.

В реальной ситуации - заказчик, покупатель вашего кода в любой момент может захотеть внести любые правки, и вы должны быть максимально к этому готовы.

Давайте посмотрим на самый простейший пример плохого кода на CSS:

```css
/* Примитивнейший пример обычного плохого кода на CSS */

/* Где-нибудь в файлах стилей: */

.selector--1 {
  width: 200px;
  height: 200px;
  border: 1px solid #ADADAD;
  border-radius: 3px;
  /* ... и дальше еще огромное количество самых разных правил */
}

.selector--2 {
  width: 200px;
  height: 400px;
  border: 1px solid #ADADAD;
  border-radius: 3px;
  /* ... и дальше еще огромное количество самых разных правил */
}
```

Не делайте так больше почти никогда! ))) Почему? Код валидный и все именно так обычно и пишут. Но все и не «верстают как бог», правильно? В большинстве случаев, а в любом проекте чуть большем чем совсем крохотный, подобный код «плохой и чреват проблемами в будущем» потому что он **конкретен и невыразителен, излишен, его сложно модифицировать и переиспользовать**.

## А как надо?

На сегодняшний день стандартной практикой для разработки CSS-кода является использование [Препроцессора](https://developer.mozilla.org/ru/docs/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C/CSS_preprocessor). **Очень многие требования современного веб-дизайна иначе было бы крайне затруднительно реализовать, особенно в маштабе крупных проектов**.  

Справедливости ради, нужно упомянуть, что последние годы, в связи с стремительным ростом популярности компонентных js-фреймворков и их подходов, все больше сторонников набирают также различные «CSS-in-JS»-реализации (например: [Styled Components](https://styled-components.com/)). Скоро, вероятно, можно будет спокойно использовать переменные в самом CSS ([CSS Custom Properties](https://developer.mozilla.org/ru/docs/Web/CSS/Using_CSS_custom_properties)). Тема холиварная, существуют контексты и ситуации когда подобный подход может оказаться более оправданным и изящным, без сомнения. Существует масса реалистичных кейсов когда проще всего будет действительно обойтись несколькими наборами правил на CSS, а любое его расширение будет излишним. Но в общем случае, в реальной коммерческой практике, имхо, для верстки сложных дизайнов и интерфейсов удобнее и эффективнее всего сейчас использовать любой препроцессор, **и, шок - даже с компонентным фреймворком**, дальше я планирую показать «как именно это лучше всего делать». Препроцессоры дают максимум возможностей и позволяют стремиться к максимальной выразительности и переиспользуемости. Вот во что превратился бы «плохой код» выше в SCSS-синтаксисе, наверное - самого популярного на сегодняшний день препроцессора - [Sass](https://sass-scss.ru/):
```scss
// В @/scss/utils/_variables.scss:

$selector__size: 200px;

$colors__border: #adadad;

$border-radius: 3px;


// В @/scss/utils/_placeholders.scss:
%border-block {
  border: 1px solid $colors__border;
  border-radius: $border-radius;
}


// В @/scss/utils/_mixins.scss:
@mixin size($width, $height) {
  width: $width;
  height: $height;
}


// В любом месте проекта:
.selector {
  &--1,
  &--2 {
    @extend %border-block;
    /* ... включение других сущностей препроцессора
      и специфическиих правил общих для селекторов */
  }

  &--1 {
    @include size($selector__size, $selector__size);
    /* ... включение других сущностей препроцессора
      и специфические правила уникальных для селектора */
  }

  &--2 {
    @include size($selector__size, ($selector__size * 2));
    /* ... включение других сущностей препроцессора
      и специфические правила уникальных для селектора */
  }

}
```

Примерно тоже самое легко сделать и на, кажется, недооценненном, но очень удачном [Stylus](https://stylus-lang.com/) - совершенно не важно какой именно расширенный синтаксис вы используете, главное как и зачем. Очень много раз мне приходилось видеть плохой чужой код написанный якобы для препроцессора, видимо, «потому что так сейчас модно», но, на самом деле, практически ничем не отличающийся от кода CSS. Не делайте так! Препроцессор дает нам крайне ценную возможность абстрагировать общие качества гайдлайна, стиль и основанные на нем частные стили, организовать их намного более выразительно и лаконично, легко модифицировать и переиспользовать при необходимости.

В данном, вырванном из контекста, но, при этом, вполне реальном примере, кажется, что кода препроцессора - сильно больше. В реальной ситуации это не так, и чем детализированнее и сложнее ваш дизайн и интерфейс, тем больше строк и времени вы будете «экономить» просто оптимизируя общие наборы правил, переиспользуя стили. Кроме того, **поддерживать код и, тем более, вносить серьезные изменения будет на порядок проще**.

Первый пример демонстрирует что на начальных этапах развития проекта некоего хорошо продуманного кода препроцессора может быть даже визуально немного больше чем неорганизаванного внутренее плоского CSS. Но давайте разберем очень часто встречающийся кейс, в котором мы очевидно экономим много трафика и явно оптимизируем возможную поддержку. Предположим, ну такое очень часто бывает - нам нужно создать большое количество - 20 штук - модификаторов одного селектора - квадратной иконки размеров в 100 пикселей - картинки в бекграунд. В Sass мы можем написать цикл с [интерполяцией](https://sass-scss.ru/documentation/sassscript/interpolyatsiya/) для создания селектора модификатора и указания пути до ресурса. И хотя данная синтаксическая возможность не является чем-то идейно очень важным - на практике она экономит кучу времени и повышает качество жизни на работе: 

```scss
// В @/scss/utils/_variables.scss:

// Paths
$images__path--root: "../assets/images/";

// Sizes 
$icons: 20;
$icons__size: 100px;


// В любом месте проекта:
.icon {
  $image-path: "../../../" + $image_path--root + "icons/";

  @include size($icons__size, $icons__size); // эта примесь уже создана выше

  @for $i from 1 through $icons {
    &.icon--#{$i} {
      background: url("#{$image-path}icon--#{$i}.svg") center center no-repeat;
    }
  }
}
```
Пример предполагает что в вашем проекте следующая структура:

```
.
├─ assets
│  └─ images
│     ├─ icon--1.svg
│     ├─ icon--2.svg
│     └─ ...
└─ sscs
   └─ utils
      └─ _variables.scss
```

Теперь в шаблонах мы можем использовать:

```html
<div class="icon icon--1"></div>
```

Если вы желаете чтобы картинки были с осмысленными именами - вы можете перебирать список:

```scss

.icon {
  $image-path: "../../../" + $image_path--root + "icons/";
  $images: "name1", "name2", "name3"; // Список имен

  @include size($icons__size, $icons__size);

  @each $image in $images {
    &.icon--#{$image} {
      background: url("#{$image-path}#{$image}.svg") center center no-repeat;
    }
  }
}
```

Ну и раз уж мы упомянули интерполяцию, необходимо вспомнить еще один очень кейс, который сейчас часто встречается и в котором вам она точно пригодится - «посчитать с переменной»:

```scss
.selector {
  $width: 100px;

  width: calc(100vw - #{$width});
}
```

Используйте на полную мощность и изучайте подробно инструменты которые используете. В хорошем коде препроцессора одинаковые наборы правил не повторяются и какдый селектор содержит только небольшое количество объявлений. **Повторяющиеся наборы и большое количество самых разных объявлений в селекторах - признак плохо организованного кода**.

## Абстрагируй все!

Маниакально абстрагируй все что только можно. Все что должно и может быть переиспользовано и любые конкретные значения, те, которые, когда-нибудь, но, в принципе, могут измениться. К примеру, на Stylus:

```stylus
// В @/stylus/utils/variables.styl:

$colors = {
  mint: #44c6a8,
  // ... другие конкретные значения цветов
}

// Создаем "основной цвет", абстрагируясь от конкретного цвета
$colors['primary'] = $colors.mint
// ... другие функциональные цвета
```

И теперь в любом месте где потребуется предоставить основной «брендовый» цвет:

```stylus
.selector
  color $colors.primary
```

Очевидно, что если весь остальной код будет аккуратно использовать правильную переменную - просто «по шелчку пальцев» возможно изменить этот основной цвет по всему интерфейсу!

## Некомпилируемые сущности препроцессора

Препроцессор должен описывать все основные качества, константы гайдлайна и дизайна, например, такую важную его общую составляющую как типографика. Или, например - медиа-запросы для адаптивности в большинстве случаев используют одни и теже значения - «брейкпоинты» - точки перехода, значения ширины окна браузера, при которых один статичный «типоразмер» дизайна перестраивается в другой. **Признаком адаптивного дизайна как раз и является наличие таких статичных типоразмеров - диапазонов ширины экрана для которых не меняется пространственная раскладка, сетки и типографика на всем протяжении.** Что, по сути, и позволяет дизайнерам покрыть «все случаи» с помощью нескольких макетов - по одному на каждый типоразмер.

Нужно помнить что плейсхолдеры не могут быть включены в медиа-запросы, но сами, при этом, могут их использовать. Вот простейший обычный очень реалистичный кейс - создадим стили препроцессора для "резинового контейнера для контента с отступами по краям вдвое меньшими на мобильных чем на остальных экранах" - очень распространенной обертки которая переиспользуется по всему интерфейсу. Объявляем переменные брекпоинтов, делаем на них удобную для использования примесь принимающую контент в медиа-запросе, используем эту адаптивную примесь в плейсхолдере, и в конце-концов - растворяем этот кусок в конкретной утилите-классе - и только этот класс будет скомпилирован в результате:   

```stylus
// В @/stylus/utils/variables.styl:
// Project variables
//////////////////////////////////////////////////////
//////////////////////////////////////////////////////

// Sizes
//////////////////////////////////////////////////////

$gutter = 20px


// Breackpoints
//////////////////////////////////////////////////////

$breackpoints = {
  min: 320px,
  xs: 359px,
  sm: 768px,
  md: 1025px,
  lg: 1240px,
}

$breackpoints['xs-max'] = $breackpoints.sm - 1
$breackpoints['sm-max'] = $breackpoints.md - 1
$breackpoints['md-max'] = $breackpoints.lg - 1


// В @/stylus/utils/mixins.styl:
// Project mixins
//////////////////////////////////////////////////////
//////////////////////////////////////////////////////

// Media
//////////////////////////////////////////////////////
// Breackpoins in stylus/utils/variables.styl

$xs()
  @media only screen and (max-width $breackpoints.xs-max)
    {block}


// В @/stylus/utils/placeholders.styl:
// Project placeholders
//////////////////////////////////////////////////////
//////////////////////////////////////////////////////

// Rubber Container
$container
  width 100%
  padding-left $gutter
  padding-right $gutter

  +$xs()
    padding-left $gutter / 2
    padding-right $gutter / 2


// В @/stylus/core/utilities.styl:
// Project utilities
//////////////////////////////////////////////////////
//////////////////////////////////////////////////////

// Elements
//////////////////////////////////////////////////////

// Rubber Container
.container-fluid
  @extends $container
```

Код опять как будто выглядит излишне громозким, «не проще ли было просто написать все с медиа-запросом в классе» и все. Но это обманчиво. Я просто демонстрирую правильный ход мыслей и действий.  **В маштабе большого проекта неукоснительное следование принципам и правилам становиться категорически важным**.